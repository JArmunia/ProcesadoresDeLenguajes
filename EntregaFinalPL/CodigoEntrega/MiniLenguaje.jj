/**
 * Especificaci�n JavaCC para la Pr�ctica 1 (Procesadores de Lenguajes)
 * Javier Fabra - jfabra@unizar.es
 * v1.1 - 2019/02/20
 */

options
{
  static = true;
  ignore_case = true;
}

PARSER_BEGIN(MiniLenguaje)
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import clasesJava.*;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;

public class MiniLenguaje
{
  public static boolean verbose = false;

  public static TreeMap < String, Integer > verboseMap = new TreeMap < String, Integer > ();

  public static Tabla_simbolos tabla_simbolos;

  public static GeneracionCodigo generacion_codigo;

  public static int nivel;

  public static final int TBD = - 1;

  public static int dir;

  public static final int DIR_INICIAL = 3;

  public static void main(String args []) throws ParseException, FileNotFoundException
  {
    if (args.length < 1 || args.length > 2)
    {
      System.out.println("Argumentos incorrectos, uso:\nMinilenguaje archivo_entrada [-v]");
    }
    for (int i = 0; i < args.length; i++)
    {
      if (args [i].equals("-v")) 
      verbose = true;
    }
    //MiniLenguaje parser = new MiniLenguaje(System.in);
    FileInputStream file = null;
    try
    {
      generacion_codigo = GeneracionCodigo.getInstancia(args [0]);
      file = new FileInputStream(args [0] + ".ml");
      MiniLenguaje parser = new MiniLenguaje(file);
    }
    catch (FileNotFoundException e)
    {
      // TODO: Explicar instrucciones de ejecución
      System.err.print("ERROR: No se ha podido encontrar el archivo: " + args [0] + ".ml");
      System.out.println("Argumentos incorrectos, uso:\nMinilenguaje archivo_entrada [-v]");
      System.out.println("(El archivo de entrada se especifica sin .ml)");
      System.exit(- 1);
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      // TODO: Explicar instrucciones de ejecución
      System.err.print("ERROR: No se ha especificado un archivo");
      System.exit(- 1);
    }
    try
    {
      MiniLenguaje.programa(verbose);
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
    catch (Error e)
    {
      System.err.println("ERROR LEXICO en la linea " + token.beginLine + ", columna " + 
      token.beginColumn + ". Simbolo no reconocido: " + token.image);
    }
  }

  private static void error_skipto(int kind)
  {
    Token t = token;
    while (t.kind != kind && t.kind != EOF)
    {
      t = getNextToken();
    }
  }

  private static void error_skipto(int kind1, int kind2)
  {
    Token t;
    do
    {
      t = getNextToken();
      System.out.println(t);
    }
    while (t.kind != kind1 && t.kind != kind2 && t.kind != EOF);
  }

  private static void error_sintactico(ParseException e)
  {
    Token t = MiniLenguaje.getNextToken();
    System.err.println("ERROR SINTACTICO en la linea " + t.beginLine + ", columna " + 
    t.beginColumn + ". Simbolo obtenido: " + t.image + "\nSe esperaba uno de: ");
    for (int i = 0; i < jj_expentries.size(); i++)
    {
      System.err.println("\t" + tokenImage [jj_expentries.get(i) [0]]);
    }
    generacion_codigo.pararGeneracionCodigo();
  }

  private static void error_semantico(Exception e)
  {
    generacion_codigo.pararGeneracionCodigo();
    System.err.println(e);
  }

  private static void error_semantico(String e)
  {
    generacion_codigo.pararGeneracionCodigo();
    System.err.println(new SemanticException(token, e));
  }

  private static RegistroExpr comprobacionExpresion(RegistroExpr r1, RegistroExpr r2, String operador)
  {
    RegistroExpr resultado = new RegistroExpr();
    if ((r1.tipo != Tipo_variable.DESCONOCIDO) && (r2.tipo != Tipo_variable.DESCONOCIDO) && 
    (r1.tipo != r2.tipo))
    {
      error_semantico("Los operandos deben ser del mismo tipo");
      resultado = new RegistroExpr(Tipo_variable.DESCONOCIDO);
    }
    else if ((r1.tipo != Tipo_variable.DESCONOCIDO) && (r2.tipo != Tipo_variable.DESCONOCIDO) && 
    (r1.tipo == r2.tipo))
    {
      resultado = new RegistroExpr(r1, r2, operador);
    }
    return resultado;
  }

  public static void addToVerboseMap(String tok)
  {
    if (verboseMap.containsKey(tok))
    {
      verboseMap.put(tok, verboseMap.get(tok) + 1);
    }
    else
    {
      verboseMap.put(tok, 1);
    }
  }

  public static void pintarTablaVerbose()
  {
    System.out.println("Tabla resumen del programa:");
    System.out.println("+-----------------------+----------------+");
    System.out.println("|TOKEN\t\t\t|APARICIONES\t |");
    System.out.println("+-----------------------+----------------+");
    String espacios = "";
    for (Map.Entry < String, Integer > entry : verboseMap.entrySet())
    {
      espacios = "";
      for (int i = 0; i < 16 - entry.getKey().length(); i++)
      {
        espacios += " ";
      }
      System.out.println("|" + entry.getKey() + espacios + "\t|\t" + entry.getValue() + "\t |");
    }
    System.out.println("+-----------------------+----------------+");
  }
}

PARSER_END(MiniLenguaje)

< DEFAULT >
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < [ "%" ] ~[ "%" ] > : COMENT
| < [ "%" ] [ "%" ] > : COMENT_MULTI
}

< COMENT >
SKIP :
{
  "\n" : DEFAULT
}

< COMENT >
SKIP :
{
  < ~[ ] >
}

< COMENT_MULTI >
SKIP :
{
  "%%" : DEFAULT
}

< COMENT_MULTI >
SKIP :
{
  < ~[ ] >
}

TOKEN : /* PALABRAS RESERVADAS */
{
  < tCLASE : "clase" >
  {
    MiniLenguaje.addToVerboseMap("tCLASE");
  }
| < tMETODO : "metodo" >
  {
    MiniLenguaje.addToVerboseMap("tMETODO");
  }
| < tPROGRAMA : "programa" >
  {
    MiniLenguaje.addToVerboseMap("tPROGRAMA");
  }
| < tVAR : "var" >
  {
    MiniLenguaje.addToVerboseMap("tVAR");
  }
| < tAND : "and" >
  {
    MiniLenguaje.addToVerboseMap("tAND");
  }
| < tOR : "or" >
  {
    MiniLenguaje.addToVerboseMap("tOR");
  }
| < tNOT : "not" >
  {
    MiniLenguaje.addToVerboseMap("tNOT");
  }
| < tPRINCIPIO : "principio" >
  {
    MiniLenguaje.addToVerboseMap("tPRINCIPIO");
  }
| < tFIN : "fin" >
  {
    MiniLenguaje.addToVerboseMap("tFIN");
  }
| < tSI : "si" >
  {
    MiniLenguaje.addToVerboseMap("tSI");
  }
| < tENT : "ent" >
  {
    MiniLenguaje.addToVerboseMap("tENT");
  }
| < tSI_NO : "si_no" >
  {
    MiniLenguaje.addToVerboseMap("tSI_NO");
  }
| < tFSI : "fsi" >
  {
    MiniLenguaje.addToVerboseMap("tFSI");
  }
| < tMQ : "mq" >
  {
    MiniLenguaje.addToVerboseMap("tMQ");
  }
| < tFMQ : "fmq" >
  {
    MiniLenguaje.addToVerboseMap("tFMQ");
  }
| < tESCRIBIR : "escribir" >
  {
    MiniLenguaje.addToVerboseMap("tESCRIBIR");
  }
| < tLEER : "leer" >
  {
    MiniLenguaje.addToVerboseMap("tLEER");
  }
| < tMOD : "mod" >
  {
    MiniLenguaje.addToVerboseMap("tMOD");
  }
| < tTRUE : "true" >
  {
    MiniLenguaje.addToVerboseMap("tTRUE");
  }
| < tFALSE : "false" >
  {
    MiniLenguaje.addToVerboseMap("tFALSE");
  }
| < tENTACAR : "entacar" >
  {
    MiniLenguaje.addToVerboseMap("tENTACAR");
  }
| < tCARAENT : "caraent" >
  {
    MiniLenguaje.addToVerboseMap("tCARAENT");
  }
| < tACCION : "accion" >
  {
    MiniLenguaje.addToVerboseMap("tACCION");
  }
| < tVAL : "val" >
  {
    MiniLenguaje.addToVerboseMap("tVAL");
  }
| < tREF : "ref" >
  {
    MiniLenguaje.addToVerboseMap("tREF");
  }
}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    MiniLenguaje.addToVerboseMap("tENTERO");
  }
| < tDECIMAL : "decimal" >
  {
    MiniLenguaje.addToVerboseMap("tDECIMAL");
  }
| < tBOOLEANO : "booleano" >
  {
    MiniLenguaje.addToVerboseMap("tBOOLEANO");
  }
| < tCARACTER : "caracter" >
  {
    MiniLenguaje.addToVerboseMap("tCARACTER");
  }
}

TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    MiniLenguaje.addToVerboseMap("tLLAVE_IZQ");
  }
| < tLLAVE_DCHA : "}" >
  {
    MiniLenguaje.addToVerboseMap("tLLAVE_DCHA");
  }
| < tPARENTESIS_IZQ : "(" >
  {
    MiniLenguaje.addToVerboseMap("tPARENTESIS_IZQ");
  }
| < tPARENTESIS_DCHA : ")" >
  {
    MiniLenguaje.addToVerboseMap("tPARENTESIS_DCHA");
  }
| < tCORCHETE_IZQ : "[" >
  {
    MiniLenguaje.addToVerboseMap("tCORCHETE_IZQ");
  }
| < tCORCHETE_DCHA : "]" >
  {
    MiniLenguaje.addToVerboseMap("tCORCHETE_DCHA");
  }
}

TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    MiniLenguaje.addToVerboseMap("tOPAS");
  }
| < tIGUAL : "=" >
  {
    MiniLenguaje.addToVerboseMap("tIGUAL");
  }
| < tFIN_SENTENCIA : ";" >
  {
    MiniLenguaje.addToVerboseMap("tFIN_SENTENCIA");
  }
| < tCOMA : "," >
  {
    MiniLenguaje.addToVerboseMap("tCOMA");
  }
| < tMAS : "+" >
  {
    MiniLenguaje.addToVerboseMap("tMAS");
  }
| < tMENOS : "-" >
  {
    MiniLenguaje.addToVerboseMap("tMENOS");
  }
| < tPOR : "*" >
  {
    MiniLenguaje.addToVerboseMap("tPOR");
  }
| < tDIV :
    "/"
  | "div" >
  {
    MiniLenguaje.addToVerboseMap("tDIV");
  }
| < tMAI : ">=" >
  {
    MiniLenguaje.addToVerboseMap("tMAI");
  }
| < tMEI : "<=" >
  {
    MiniLenguaje.addToVerboseMap("tMEI");
  }
| < tNI : "<>" >
  {
    MiniLenguaje.addToVerboseMap("tNI");
  }
| < tMAYOR : ">" >
  {
    MiniLenguaje.addToVerboseMap("tMAYOR");
  }
| < tMENOR : "<" >
  {
    MiniLenguaje.addToVerboseMap("tMENOR");
  }
}

SKIP :
{
  "\"" : STRING
}

< STRING >
SKIP :
{
  < "\"" > 
  : DEFAULT
}

< STRING >
TOKEN :
{
  < tCHAR : (~[ "\"" ]) >
  {
    MiniLenguaje.addToVerboseMap("tCHAR");
  }
}

< STRING >
TOKEN :
{
  < tSTRING : (~[ "\"" ])+ >
  {
    MiniLenguaje.addToVerboseMap("tSTRING");
  }
}

TOKEN : /* VALORES */
{
  < tIDENTIFICADOR :
    ([ "a"-"z", "_" ]) ([ "a"-"z", "_", "0"-"9" ])* ([ "a"-"z", "0"-"9" ])
  | ([ "a"-"z", "_" ]) >
  {
    MiniLenguaje.addToVerboseMap("tIDENTIFICADOR");
  }
| < tVALOR_ENTERO : ([ "0"-"9" ])+ >
  {
    MiniLenguaje.addToVerboseMap("tENTERO");
  }
| < tVALOR_DECIMAL : ([ "0"-"9" ])+ "." ([ "0"-"9" ])+ >
  {
    MiniLenguaje.addToVerboseMap("tDECIMAL");
  }
}

/************************************
************* PROGRAMA **************
*************************************/

// <tPROGRAMA> <tIDENTIFICADOR> <tFIN_SENTENCIA> declaracion_variables() declaracion_acciones() bloque_sentencias()
void programa(boolean verbose) :
{
  tabla_simbolos = Tabla_simbolos.inicializar_tabla(31);
  nivel = 0;
  dir = DIR_INICIAL;
  String etiq = "";
  Token t = null;
}
{
  try
  {
    try
    {
      < tPROGRAMA > t = < tIDENTIFICADOR >
      {
        tabla_simbolos.introducir_programa(t.image, TBD);
        etiq = generacion_codigo.getEtiqueta();
        generacion_codigo.escribir("; Programa " + t.image);
        generacion_codigo.escribir("ENP " + etiq);
      }
      < tFIN_SENTENCIA >
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
    try
    {
      declaracion_variables()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
    try
    {
      declaracion_acciones()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
    {
      generacion_codigo.escribir("; Comienzo de " + t.image);
      generacion_codigo.escribir(etiq + ":");
    }
    try
    {
      bloque_sentencias()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
    {
      tabla_simbolos.eliminar_programa();
      generacion_codigo.escribir("; Fin de " + t.image);
      generacion_codigo.escribir("LVP");
      //System.out.println("Fin de " + t.image);
    }
    < EOF >
    {
      generacion_codigo.escribirPrograma();
      if (verbose)
      {
        pintarTablaVerbose();
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    generacion_codigo.escribirPrograma();
    if (verbose)
    {
      pintarTablaVerbose();
    }
  }
}

// (declaracion()<tFIN_SENTENCIA>)*
void declaracion_variables() :
{}
{
  (
    try
    {
      declaracion() < tFIN_SENTENCIA >
    }
    catch (ParseException e)
    {
      error_sintactico(e);
      declaracion_variables();
    }
  )*
}

// tipo_variables() identificadores()
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList < RegistroIdentificador > identificadores;
  Simbolo s;
}
{
  try
  {
    tipo = tipo_variables() 
    identificadores = identificadores()
    {
      for (RegistroIdentificador identificador : identificadores)
      {
        s = tabla_simbolos.introducir_variable(identificador.nombre, tipo, nivel, dir);
        if (s == null)
        {
          error_semantico(new ExcepcionTablaSimbolos(identificador.nombre, token.beginLine, nivel, tabla_simbolos.buscar_simbolo(identificador.nombre)));
        }
        else
        {
          if (identificador.isVector)
          {
            s.setVector(true);
            s.setLongitud(identificador.size);
          }
          dir = dir + s.getLongitud();
        }
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tENTERO> | <tCARACTER> | <tBOOLEANO> | <tDECIMAL>
Tipo_variable tipo_variables() :
{}
{
  < tENTERO >
  {
    return Tipo_variable.ENTERO;
  }
| < tCARACTER >
  {
    return Tipo_variable.CHAR;
  }
| < tBOOLEANO >
  {
    return Tipo_variable.BOOLEANO;
  }
| < tDECIMAL >
  {
    return Tipo_variable.DECIMAL;
  }
}

// <tIDENTIFICADOR>(<tCOMA><tIDENTIFICADOR>)*
ArrayList < RegistroIdentificador > identificadores() :
{
  ArrayList < RegistroIdentificador > identificadores = new ArrayList();
  Token t, size;
  RegistroIdentificador regId;
}
{
  try
  {
    t = < tIDENTIFICADOR >
    {
      regId = new RegistroIdentificador(t.image);
      identificadores.add(regId);
    }
    (< tCORCHETE_IZQ > size = < tVALOR_ENTERO > < tCORCHETE_DCHA >
    {
      regId.size = Integer.parseInt(size.image);
      regId.isVector = true;
    }
    ) ? 
    (
    < tCOMA > t = < tIDENTIFICADOR >
    {
      regId = new RegistroIdentificador(t.image);
      identificadores.add(regId);
    }
    (< tCORCHETE_IZQ > size = < tVALOR_ENTERO > < tCORCHETE_DCHA >
    {
      regId.size = Integer.parseInt(size.image);
      regId.isVector = true;
    }
    ) ?
    // TODO: Poner tamaño en la tabla de simbolos
    ) *
    {
      return identificadores;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return identificadores;
  }
}

// (declaracion_accion())*
void declaracion_acciones() :
{}
{
  (
    try
    {
      declaracion_accion()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
      declaracion_acciones();
    }
  )*
}

// cabecera_accion() <tFIN_SENTENCIA> declaracion_variables() declaracion_acciones() bloque_sentencias()
void declaracion_accion() :
{
  int dir_prev = dir;
  dir = DIR_INICIAL;
  String etiquetaAccion = generacion_codigo.getEtiqueta(), etiq = generacion_codigo.getEtiqueta();
  Token t;
}
{
  try
  {
    {
      generacion_codigo.escribir(etiquetaAccion + ":");
    }
    t = cabecera_accion(etiquetaAccion)
    {
      generacion_codigo.escribir("JMP " + etiq);
    }
    < tFIN_SENTENCIA > 
    declaracion_variables() 
    declaracion_acciones()
    {
      generacion_codigo.escribir("; Codigo accion " + t.image);
      generacion_codigo.escribir(etiq + ":");
    }
    bloque_sentencias()
    {
      generacion_codigo.escribir("CSF ");
      generacion_codigo.escribir("; Fin accion " + t.image);
      dir = dir_prev;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    declaracion_variables();
    declaracion_acciones();
    bloque_sentencias();
  }
}

// <tACCION> <tIDENTIFICADOR> parametros_formales()
Token cabecera_accion(String etiqueta) :
{
  ArrayList < Simbolo > parametros;
  Simbolo accion, s;
  Boolean buscarParametros = true;
  Token t;
}
{
  try
  {
    < tACCION > t = < tIDENTIFICADOR >
    {
      generacion_codigo.escribir("; Declaraciones accion " + t.image);
      accion = tabla_simbolos.introducir_accion(t.image, nivel, etiqueta);
      if (accion == null)
      {
        error_semantico(new ExcepcionTablaSimbolos(t, nivel, tabla_simbolos.buscar_simbolo(token.image)));
        buscarParametros = false;
      }
      nivel++;
      //System.out.println("Aumenta nivel accion: " + accion.getNombre() + " nivel: " + nivel);
    }
    parametros = parametros_formales()
    {
      if (buscarParametros)
      {
        for (Simbolo parametro : parametros)
        {
          accion.introducir_parametro(parametro);
        }
        generacion_codigo.escribir("; Parametros accion " + t.image);
        for (int i = parametros.size() - 1; i >= 0; i--)
        {
          s = parametros.get(i);
          if (s.esVector() && s.esValor())
          {
            for (int j = s.getLongitud() - 1; j >= 0; j--)
            {
              generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + (s.getDireccion() + j));
              generacion_codigo.escribir("ASGI");
            }
          }
          else
          {
            generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
            generacion_codigo.escribir("ASGI");
          }
        }
      }
      return t;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// ((<tPARENTESIS_IZQ> parametros()) (<tFIN_SENTENCIA> parametros())* <tPARENTESIS_DCHA>)? 
ArrayList < Simbolo > parametros_formales() :
{
  ArrayList < Simbolo > parametros = new ArrayList < Simbolo > ();
  ArrayList < Simbolo > masParametros;
}
{
  try
  {
    (
    (
    < tPARENTESIS_IZQ > parametros = parametros()
    ) 
    (
    < tFIN_SENTENCIA > masParametros = parametros()
    {
      parametros.addAll(masParametros);
    }
    ) * 
    < tPARENTESIS_DCHA >
    ) ?
    {
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < Simbolo > lista_parametros(Clase_parametro clase, Tipo_variable tipo) :
{
  ArrayList < RegistroIdentificador > identificadores;
  ArrayList < Simbolo > parametros = new ArrayList();
  Simbolo parametro;
}
{
  try
  {
    identificadores = identificadores()
    {
      for (RegistroIdentificador identificador : identificadores)
      {
        parametro = tabla_simbolos.introducir_parametro(identificador.nombre, tipo, clase, nivel, dir);
        if (identificador.isVector)
        {
          parametro.setVector(true);
          parametro.setLongitud(identificador.size);
        }
        if (parametro == null)
        {
          error_semantico(new ExcepcionTablaSimbolos(identificador.nombre, token.beginLine, nivel, tabla_simbolos.buscar_simbolo(identificador.nombre)));
        }
        else
        {
          if (parametro.esVector() && parametro.esReferencia())
          {
            dir = dir + 1;
          }
          else
          {
            dir = dir + parametro.getLongitud();
          }
          parametros.add(parametro);
        }
      }
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// clase_parametros() tipo_variables() lista_parametros()
ArrayList < Simbolo > parametros() :
{
  Clase_parametro clase;
  Tipo_variable tipo;
  ArrayList < Simbolo > parametros = new ArrayList();
}
{
  try
  {
    clase = clase_parametros() 
    tipo = tipo_variables() 
    parametros = lista_parametros(clase, tipo)
    {
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// <tVAL> | <tREF>
Clase_parametro clase_parametros() :
{}
{
  < tVAL >
  {
    return Clase_parametro.VAL;
  }
| < tREF >
  {
    return Clase_parametro.REF;
  }
}

// <tPRINCIPIO> lista_sentencias() <tFIN>
void bloque_sentencias() :
{}
{
  try
  {
    < tPRINCIPIO > lista_sentencias() < tFIN >
    {
      //System.out.println("######################################################################################");    
      //System.out.println("Tabla antes de borrar nivel " + nivel);
      //System.out.println(tabla_simbolos);
      tabla_simbolos.ocultar_parametros(nivel);
      tabla_simbolos.eliminar_variables(nivel);
      // Elimino los parámetros ocultos al eliminar las acciones
      tabla_simbolos.eliminar_acciones(nivel);
      nivel--;
      //System.out.println("\nTabla despues de borrar nivel " + (nivel + 1));
      //System.out.println(tabla_simbolos);
      //System.out.println("######################################################################################");
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// (sentencia())* 
void lista_sentencias() :
{}
{
  (
    try
    {
      sentencia()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
  )+
}

/*
leer()  < tFIN_SENTENCIA >|
  escribir() < tFIN_SENTENCIA >|
  < tIDENTIFICADOR > [asignacion() |  invocacion_accion() ] < tFIN_SENTENCIA > |
  seleccion()  |
  mientras_que()
  */
void sentencia() :
{
  Token identificador;
}
{
  try
  {
    leer() < tFIN_SENTENCIA >
  | 
    escribir() < tFIN_SENTENCIA >
  | 
    identificador = < tIDENTIFICADOR >
    [
      asignacion(identificador)
    | invocacion_accion(identificador)
    ]
  | 
    seleccion()
  | 
    mientras_que()
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tLEER> <tPARENTESIS_IZQ> lista_asignables() <tPARENTESIS_DCHA>
void leer() :
{
  ArrayList < Token > asignables = new ArrayList();
  Simbolo s;
}
{
  try
  {
    < tLEER > < tPARENTESIS_IZQ > asignables = lista_asignables() < tPARENTESIS_DCHA >
    {
      for (Token t : asignables)
      {
        s = tabla_simbolos.buscar_simbolo(t.image);
        if (s == null)
        {
          error_semantico("Identificador desconocido: " + t.image);
          tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, nivel, TBD);			
        }
        else if (s.getTipoSimbolo() == Tipo_simbolo.ACCION)
        {
          error_semantico("No se puede asignar el simbolo " + t.image + " ya que es una accion");
        }
        else if (s.getVariable() != Tipo_variable.CHAR 
        && s.getVariable() != Tipo_variable.ENTERO 
        && s.getVariable() != Tipo_variable.DESCONOCIDO)
        {
          error_semantico("No se puede asignar la variable " + t.image + " ya que es de tipo " + s.getVariable());
        }
        else if (s.esParametro() && s.esValor())
        {
          error_semantico("No se puede asignar " + t.image + " ya que es un parametro por valor");
        }
        // Generacion codigo
        if (s != null && !s.esAccion())
        {
          generacion_codigo.escribir("; Leer");
          generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
          if (s.esParametro() && s.esReferencia())
          {
            generacion_codigo.escribir("DRF");
          }
          if (s.esChar())
          {
            generacion_codigo.escribir("RD 0");
          }
          else
          {
            generacion_codigo.escribir("RD 1");
          }
        }
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tIDENTIFICADOR> (<tCOMA> <tIDENTIFICADOR>)*
ArrayList < Token > lista_asignables() :
{
  ArrayList < Token > asignables = new ArrayList();
  Token t;
}
{
  try
  {
    t = < tIDENTIFICADOR >
    {
      asignables.add(t);
    }
    (< tCOMA > t = < tIDENTIFICADOR >
    {
      asignables.add(t);
    }
    ) *
    {
      return asignables;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return asignables;
  }
}

// <tESCRIBIR> <tPARENTESIS_IZQ> lista_escribibles() <tPARENTESIS_DCHA>
void escribir() :
{
  ArrayList < RegistroExpr > escribibles = new ArrayList();
}
{
  try
  {
    < tESCRIBIR > < tPARENTESIS_IZQ >
    {
      generacion_codigo.escribir("; Escribir ");
    }
    escribibles = lista_escribibles() < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < RegistroExpr > lista_escribibles() :
{
  ArrayList < RegistroExpr > escribibles = new ArrayList();
  RegistroExpr r, resultado;
  Token string;
}
{
  try
  {
    (r = expresion(Clase_parametro.VAL)
    {
      if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool)
        {
          resultado = new RegistroExpr("Verdadero");
        }
        else
        {
          resultado = new RegistroExpr("False");
        }
      }
      else if (r.tipo == Tipo_variable.ENTERO && r.valorEnt != null)
      {
        resultado = new RegistroExpr("" + r.valorEnt);
      }
      else // Si es de tipo char, entero, desconocido o un booleano con valor nulo, no hacen falta transformaciones
      {
        resultado = new RegistroExpr("" + r.valorChar);
      }
      escribibles.add(resultado);
      // Generacion codigo
      if (r.tipo == Tipo_variable.ENTERO)
      {
        generacion_codigo.escribir("WRT 1");
      }
      else if (r.tipo == Tipo_variable.CHAR)
      {
        generacion_codigo.escribir("WRT 0");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO)
      {
        String etiquetaFALSO = generacion_codigo.getEtiqueta();
        String etiquetaFIN = generacion_codigo.getEtiqueta();
        generacion_codigo.escribir("JMF " + etiquetaFALSO);
        generacion_codigo.escribir("STC \"V\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"e\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"r\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"d\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"a\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"d\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"e\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"r\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"o\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("JMP " + etiquetaFIN);
        generacion_codigo.escribir( etiquetaFALSO + ":");

        generacion_codigo.escribir("STC \"F\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"a\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"l\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"s\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"o\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir( etiquetaFIN + ":");
      }
    }
  | string = < tSTRING >
    {
      resultado = new RegistroExpr(string.image);
      escribibles.add(resultado);
      generacion_codigo.escribir("; " + resultado.valorChar);
      for (int i = 0; i < resultado.valorChar.length(); i++)
      {
        generacion_codigo.escribir("STC " + (int) resultado.valorChar.charAt(i));
        generacion_codigo.escribir("WRT 0");
      }
    }
    ) 
    (
    < tCOMA > 
    (r = expresion(Clase_parametro.VAL)
    {
      if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool)
        {
          resultado = new RegistroExpr("Verdadero");
        }
        else
        {
          resultado = new RegistroExpr("False");
        }
      }
      else if (r.tipo == Tipo_variable.ENTERO && r.valorEnt != null)
      {
        resultado = new RegistroExpr("" + r.valorEnt);
      }
      else // Si es de tipo char, entero, desconocido o un booleano con valor nulo, no hacen falta transformaciones
      {
        resultado = new RegistroExpr("" + r.valorChar);
      }
      escribibles.add(resultado);
      // Generacion codigo
      if (r.tipo == Tipo_variable.ENTERO)
      {
        generacion_codigo.escribir("WRT 1");
      }
      else if (r.tipo == Tipo_variable.CHAR)
      {
        generacion_codigo.escribir("WRT 0");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO)
      {
        String etiquetaFALSO = generacion_codigo.getEtiqueta();
        String etiquetaFIN = generacion_codigo.getEtiqueta();
        generacion_codigo.escribir("JMF " + etiquetaFALSO);
        generacion_codigo.escribir("STC \"V\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"e\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"r\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"d\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"a\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"d\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"e\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"r\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"o\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("JMP " + etiquetaFIN);
        generacion_codigo.escribir( etiquetaFALSO + ":");

        generacion_codigo.escribir("STC \"F\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"a\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"l\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"s\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir("STC \"o\"");
        generacion_codigo.escribir("WRT 0");
        generacion_codigo.escribir( etiquetaFIN + ":");
      }
    }
  | string = < tSTRING >
    {
      resultado = new RegistroExpr(string.image);
      escribibles.add(resultado);
      generacion_codigo.escribir("; " + resultado.valorChar);
      for (int i = 0; i < resultado.valorChar.length(); i++)
      {
        generacion_codigo.escribir("STC " + (int) resultado.valorChar.charAt(i));
        generacion_codigo.escribir("WRT 0");
      }
    }
    )
    ) *
    {
      return escribibles;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return escribibles;
  }
}

// <tOPAS> expresion() 
void asignacion(Token t) :
{
  Simbolo s;
  RegistroExpr r, rVec;
  Tipo_variable tipoID;
}
{
  try
  {
    {
      s = tabla_simbolos.buscar_simbolo(t.image);
      if (s == null)
      {
        error_semantico("Identificador desconocido en la parte izquierda de la asignacion: " + t.image);
        tipoID = Tipo_variable.DESCONOCIDO;
        tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, nivel, TBD);
      }
      else
      {
        if (s.esParametro() && s.esValor())
        {
          error_semantico("No se puede realizar una asignacion a un parametro por valor");
        }
        else if (s.esAccion())
        {
          error_semantico("No se puede realizar una asignacion a una accion");
        }
        tipoID = s.getVariable();
        generacion_codigo.escribir("; Asignacion de " + t.image);
        generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
        if (s.esParametro() && s.esReferencia())
        {
          generacion_codigo.escribir("DRF");
        }
      }
    }
    (< tCORCHETE_IZQ > rVec = expresion(Clase_parametro.VAL) < tCORCHETE_DCHA >
    {
      if (rVec.tipo != Tipo_variable.DESCONOCIDO && rVec.tipo != Tipo_variable.ENTERO)
      {
        error_semantico("El tipo del indice del vector debe ser entero");
      }
      else if (rVec.tipo == Tipo_variable.ENTERO && rVec.valorEnt != null)
      {
        if (rVec.valorEnt >= Math.pow(2, 8) || rVec.valorEnt < - Math.pow(2, 8))
        {
          error_semantico("Overflow en el indice del vector");
        }
        if (rVec.valorEnt < 0)
        {
          error_semantico("El indice del vector debe ser positivo");
        }
        if (rVec.valorEnt >= s.getLongitud())
        {
          error_semantico("Se ha intentado acceder a una posicion mayor que la longitud del vector, posicion: " 
          + rVec.valorEnt + " longitud: " + s.getLongitud());
        }
      }
      generacion_codigo.escribir("PLUS");
    }
    ) ? 
    // TODO: Comprobar resultado entero (O desconocido), que el resultado no sea mayor que la longitud del vector
    < tOPAS > r = expresion(Clase_parametro.VAL)
    {
      if ((tipoID != Tipo_variable.DESCONOCIDO) && (r.tipo != Tipo_variable.DESCONOCIDO) && (tipoID != r.tipo))
      {
        error_semantico("Tipos incompatibles en la asignacion");
      }
      if (r.isVector && r.longitud != s.getLongitud())
      {
        error_semantico("No se puede realizar la asignacion porque los vectores no tienen la misma longitud\nLongitud izq: " 
        + s.getLongitud() + " longitud dch: " + r.longitud);
      }
      generacion_codigo.escribir("ASG");
      if (r.isVector && r.longitud == s.getLongitud())
      {
        for (int i = 1; i < s.getLongitud(); i++)
        {
          generacion_codigo.escribir("; Asignacion " + r.simbolo.getNombre() + "[" + i + "]");
          generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
          if (s.esParametro() && s.esReferencia())
          {
            generacion_codigo.escribir("DRF");
          }
          generacion_codigo.escribir("STC " + i);
          generacion_codigo.escribir("PLUS");
          if (r.simbolo.esParametro() && r.simbolo.esReferencia())
          {
            generacion_codigo.escribir("SRF " + (nivel - r.simbolo.getNivel()) + " " + (r.simbolo.getDireccion()));
            generacion_codigo.escribir("DRF");
            generacion_codigo.escribir("STC " + i);
            generacion_codigo.escribir("PLUS");
            generacion_codigo.escribir("ASG");
          }
          else
          {
            generacion_codigo.escribir("SRF " + (nivel - r.simbolo.getNivel()) + " " + (r.simbolo.getDireccion() + i));
            generacion_codigo.escribir("DRF");
            generacion_codigo.escribir("ASG");
          }
        }
      }
    }
    < tFIN_SENTENCIA >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// argumentos() 
void invocacion_accion(Token t) :
{
  Simbolo accion, paramOriginal;
  ArrayList < RegistroExpr > args = new ArrayList();
  RegistroExpr param;
}
{
  try
  {
    {
      accion = tabla_simbolos.buscar_simbolo(t.image);
      if (accion == null)
      {
        error_semantico("Identificador de accion desconocido: " + t.image);
        accion = tabla_simbolos.introducir_accion(t.image, nivel, null);
        accion.setVariable(Tipo_variable.DESCONOCIDO);			
      }
      else if (!accion.esAccion())
      {
        error_semantico(t.image + " no es una accion");
      }
    }
    (
    args = argumentos(accion.getListaParametros())) ? < tFIN_SENTENCIA >
    {
      if (accion.getVariable() != Tipo_variable.DESCONOCIDO)
      {
        if (args.size() != accion.getListaParametros().size())
        {
          error_semantico("El numero de parametros no coincide con el de la accion " + 
          t.image + ", se han proporcionado " + args.size() + " pero se requieren " + accion.getListaParametros().size());
        }
        else
        {
          for (int i = 0; i < args.size(); i++)
          {
            // TODO: Comprobar tipo de los parametros
            paramOriginal = accion.getListaParametros().get(i);
            param = args.get(i);
            //System.out.println(Arrays.toString(args.toArray()));
            //System.out.println(param + " accion: " + accion.getNombre() + " parametro: " + paramOriginal);
            if (paramOriginal.getVariable() != param.tipo 
            && param.tipo != Tipo_variable.DESCONOCIDO)
            {
              error_semantico("El tipo del parametro en la posicion " + i + 
              " no coincide, deberia ser " + paramOriginal.getVariable() + 
              " pero es " + param.tipo + " en la accion " + accion.getNombre());
            }
            if (paramOriginal.getParametro() == Clase_parametro.REF 
            && param.parametro != Clase_parametro.REF)
            {
              error_semantico("El parametro en la posicion " + i + 
              " deberia ser un parametro por referencia, pero se ha pasado un parametro por valor" + 
              " en la accion " + accion.getNombre());
            }
            if (paramOriginal.getLongitud() != param.longitud)
            {
              error_semantico("El parametro en la posicion " + i + 
              " no tiene la longitud necesitada, deberia tener longitud " + paramOriginal.getLongitud() + 
              " pero tiene longitud " + param.longitud);
            }
          }
        }
        generacion_codigo.escribir("; Invocacion accion " + accion.getNombre());
        generacion_codigo.escribir("OSF " + (dir - 1) + " " + (nivel - accion.getNivel()) + " " + accion.getEtiqueta());
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tMQ> expresion() lista_sentencias() <tFMQ>
void mientras_que() :
{
  RegistroExpr r;
  String etiqMQ, etiqFin;
}
{
  try
  {
    < tMQ >
    {
      etiqMQ = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir(etiqMQ + ":");
    }
    r = expresion(Clase_parametro.VAL)
    {
      etiqFin = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("; Mq");
      generacion_codigo.escribir("JMF " + etiqFin);
      if (r.tipo != Tipo_variable.DESCONOCIDO && r.tipo != Tipo_variable.BOOLEANO)
      {
        error_semantico("La condicion en el mientras_que debe ser un booleano");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool == true)
        {
          error_semantico("Bucle infinito");
        }
        else
        {
          error_semantico("Nunca se entra en el bucle");
        }
      }
    }
    lista_sentencias() < tFMQ >
    {
      generacion_codigo.escribir("JMP " + etiqMQ);
      generacion_codigo.escribir(etiqFin + ":");
      generacion_codigo.escribir("; Fin mq");	
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tSI> expresion() <tENT> lista_sentencias() (<tSI_NO> lista_sentencias())?  <tFSI>
void seleccion() :
{
  RegistroExpr r;
  String etiqSINO, etiqFin;
}
{
  try
  {
    {
      generacion_codigo.escribir("; Si");
    }
    < tSI > r = expresion(Clase_parametro.VAL)
    {
      etiqSINO = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("JMF " + etiqSINO);
      generacion_codigo.escribir("; Ent");
      if (r.tipo != Tipo_variable.DESCONOCIDO && r.tipo != Tipo_variable.BOOLEANO)
      {
        error_semantico("La condicion la seleccion debe ser un booleano");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool == true)
        {
          error_semantico("La condicion es siempre cierta");
        }
        else
        {
          error_semantico("La condicion nunca es cierta");
        }
      }
    }
    < tENT > lista_sentencias()
    {
      etiqFin = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("JMP " + etiqFin);
      generacion_codigo.escribir("; Si no");
      generacion_codigo.escribir(etiqSINO + ":");
    }
    (
    < tSI_NO > lista_sentencias()
    ) ? 
    < tFSI >
    {
      generacion_codigo.escribir(etiqFin + ":");
      generacion_codigo.escribir("; Fin si");
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tPARENTESIS_IZQ> (lista_expresiones())? <tPARENTESIS_DCHA>
ArrayList < RegistroExpr > argumentos(ArrayList < Simbolo > parametros_accion) :
{
  ArrayList < RegistroExpr > args = new ArrayList();
}
{
  try
  {
    < tPARENTESIS_IZQ > 
    (
    args = lista_expresiones(parametros_accion)
    ) ? 
    < tPARENTESIS_DCHA >
    {
      return args;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return args;
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < RegistroExpr > lista_expresiones(ArrayList < Simbolo > parametros_accion) :
{
  ArrayList < RegistroExpr > args = new ArrayList();
  RegistroExpr r;
  Clase_parametro param = null;
  int i = 0;
}
{
  try
  {
    {
      if (i < parametros_accion.size())
      {
        param = parametros_accion.get(i).getParametro();
        i++;		
      }
    }
    r = expresion(param)
    {
      args.add(r);
    }
    (
    < tCOMA >
    {
      if (i < parametros_accion.size())
      {
        param = parametros_accion.get(i).getParametro();
        i++;		
      }
      else
      {
        param = null;
      }
    }
    r = expresion(param)
    {
      args.add(r);
    }
    ) *
    {
      return args;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return args;
  }
}

// expresion_simple() (operador_relacional() expresion_simple())*
RegistroExpr expresion(Clase_parametro param) :
{
  RegistroExpr r1, r2;
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = expresion_simple(param) 
    (
    token_operador = operador_relacional() 
    r2 = expresion_simple(param)
    {
      if (r1.isVector || r2.isVector)
      {
        error_semantico("No se puede operar con un vector");
      }
      operador = token_operador.image;
      r1 = comprobacionExpresion(r1, r2, operador);
      switch (operador)
      {
        case "=" : 
        generacion_codigo.escribir("EQ");
        break;
        case "<>" : 
        generacion_codigo.escribir("NEQ");
        break;
        case "<" : 
        generacion_codigo.escribir("LT");
        break;
        case "<=" : 
        generacion_codigo.escribir("LTE");
        break;
        case ">" : 
        generacion_codigo.escribir("GT");
        break;
        case ">=" : 
        generacion_codigo.escribir("GTE");
        break;
      }
    }
    ) ?
    {
      //System.out.println(r1);
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tMAYOR> | <tMENOR> | <tMAI> | <tMEI> | <tNI> | <tIGUAL>
Token operador_relacional() :
{
  Token t;
}
{
  t = < tMAYOR >
  {
    return t;
  }
| t = < tMENOR >
  {
    return t;
  }
| t = < tMAI >
  {
    return t;
  }
| t = < tMEI >
  {
    return t;
  }
| t = < tNI >
  {
    return t;
  }
| t = < tIGUAL >
  {
    return t;
  }
}

// termino() (operador_aditivo() termino())*
RegistroExpr expresion_simple(Clase_parametro param) :
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = termino(param) 
    (
    token_operador = operador_aditivo() 
    r2 = termino(param)
    {
      if (r1.isVector || r2.isVector)
      {
        error_semantico("No se puede operar con un vector");
      }
      operador = token_operador.image;
      switch (operador.toLowerCase())
      {
        case "+" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= Math.pow(2, 8) || r1.valorEnt < (- Math.pow(2, 8))))
          {
            error_semantico("Error de overflow/underflow al realizar la suma.");
            r1.valorEnt = null;
          }
        }
        generacion_codigo.escribir("PLUS");
        break;
        case "-" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= Math.pow(2, 8) || r1.valorEnt < (- Math.pow(2, 8))))
          {
            error_semantico("Error de overflow/underflow al realizar la resta.");
            r1.valorEnt = null;
          }
        }
        generacion_codigo.escribir("SBT");
        break;
        case "or" : 
        if ((r1.tipo != Tipo_variable.BOOLEANO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.BOOLEANO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba booleano.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);				
        }
        generacion_codigo.escribir("OR");
        break;
      }
    }
    ) *
    {
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return r1;
  }
}

// <tMAS> | <tMENOS> | <tOR>
Token operador_aditivo() :
{
  Token t;
}
{
  t = < tMAS >
  {
    return t;
  }
| t = < tMENOS >
  {
    return t;
  }
| t = < tOR >
  {
    return t;
  }
}

// factor() (operador_multiplicativo() factor())* 
RegistroExpr termino(Clase_parametro param) :
{
  RegistroExpr r1 = new RegistroExpr(), r2 = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = factor(param)
    {
    }
    (
    token_operador = operador_multiplicativo() 
    r2 = factor(param)
    {
      if (r1.isVector)
      {
        error_semantico("No se puede operar con un vector");
      }
      if (r2.isVector)
      {
        error_semantico("No se puede operar con un vector");
      }
      operador = token_operador.image;
      switch (operador.toLowerCase())
      {
        case "*" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= Math.pow(2, 8) || r1.valorEnt < (- Math.pow(2, 8))))
          {
            error_semantico("Error de overflow/underflow al realizar la multiplicacion.");
            r1.valorEnt = null;
          }
        }
        generacion_codigo.escribir("TMS");
        break;
        case "div" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Division por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        generacion_codigo.escribir("DIV");
        break;
        case "/" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Division por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        generacion_codigo.escribir("DIV");
        break;
        case "mod" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Modulo por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        generacion_codigo.escribir("MOD");
        break;
        case "and" : 
        if ((r1.tipo != Tipo_variable.BOOLEANO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.BOOLEANO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba booleano.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {				
          r1 = new RegistroExpr(r1, r2, operador);						
        }
        generacion_codigo.escribir("AND");
        break;			
      }
    }
    ) *
    {
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return r1;
  }
}

// <tPOR> | <tDIV> | <tMOD> | <tAND>
Token operador_multiplicativo() :
{
  Token t;
}
{
  t = < tPOR >
  {
    return t;
  }
| t = < tDIV >
  {
    return t;
  }
| t = < tMOD >
  {
    return t;
  }
| t = < tAND >
  {
    return t;
  }
}

/*
	< tMENOS > factor()
| < tNOT > factor()
| < tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tENTACAR > <tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tCARAENT > <tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tIDENTIFICADOR >
| < tVALOR_ENTERO >
| < tVALOR_DECIMAL >
| < tSTRING >
| < tTRUE >
| < tFALSE >
*/
RegistroExpr factor(Clase_parametro param) :
{
  RegistroExpr rExpr = new RegistroExpr(), rVec = new RegistroExpr();
  Token t;
  Simbolo s;
  Boolean indice_seleccionado = false;
}
{
  try
  {
    < tMENOS > rExpr = factor(param)
    {
      if ((rExpr.tipo != Tipo_variable.ENTERO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.ENTERO));
        rExpr.tipo = Tipo_variable.ENTERO;
      }
      if (rExpr.valorEnt != null)
      {
        rExpr.valorEnt = - rExpr.valorEnt;
      }
      if (rExpr.isVector)
      {
        error_semantico("No se puede operar con un vector");
      }
      generacion_codigo.escribir("NGI");
      return rExpr;
    }
  | < tNOT > rExpr = factor(param)
    {
      if ((rExpr.tipo != Tipo_variable.BOOLEANO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.BOOLEANO));
        rExpr.tipo = Tipo_variable.BOOLEANO;
      }
      if (rExpr.isVector)
      {
        error_semantico("No se puede operar con un vector");
      }
      if (rExpr.valorBool != null)
      {
        rExpr.valorBool = !rExpr.valorBool;
      }
      generacion_codigo.escribir("NGB");
      return rExpr;
    }
  | < tPARENTESIS_IZQ > rExpr = expresion(param) < tPARENTESIS_DCHA >
    {
      return rExpr;
    }
  | < tENTACAR > < tPARENTESIS_IZQ > rExpr = expresion(param) < tPARENTESIS_DCHA >
    {
      if ((rExpr.tipo != Tipo_variable.ENTERO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.ENTERO));
      }
      if ((rExpr.valorEnt != null) && ((rExpr.valorEnt > 255) || (rExpr.valorEnt < 0)))
      {
        error_semantico("La expresion no se puede convertir en un caracter valido");
      }
      if (rExpr.isVector)
      {
        error_semantico("No se puede transformar un vector a caracter");
      }
      rExpr.tipo = Tipo_variable.CHAR;
      return rExpr;
    }
  | < tCARAENT > < tPARENTESIS_IZQ > rExpr = expresion(param) < tPARENTESIS_DCHA >
    {
      if ((rExpr.tipo != Tipo_variable.CHAR) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.CHAR));
      }
      if (rExpr.isVector)
      {
        error_semantico("No se puede transformar un vector a entero");
      }
      rExpr.tipo = Tipo_variable.ENTERO;
      return rExpr;
    }
  | t = < tIDENTIFICADOR >
    {
      s = tabla_simbolos.buscar_simbolo(t.image);
      rExpr = new RegistroExpr();
      if (s == null)
      {
        error_semantico("Identificador desconocido: " + t.image);
        s = tabla_simbolos.introducir_variable(token.image, Tipo_variable.DESCONOCIDO, nivel, TBD);	
        rExpr.tipo = Tipo_variable.DESCONOCIDO;
      }
      else if (s.esAccion())
      {
        error_semantico("No se puede utilizar una accion como expresion");
      }
      else
      {
        generacion_codigo.escribir("; Variable " + t.image);
        generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
        rExpr.tipo = s.getVariable();
        if (s.esParametro())
        {
          rExpr.parametro = s.getParametro();
          if (s.esReferencia())
          {
            generacion_codigo.escribir("DRF");
          }
        }
      }
    }
    (< tCORCHETE_IZQ > rVec = expresion(Clase_parametro.VAL) < tCORCHETE_DCHA >
    {
      if (!s.esVector())
      {
        error_semantico("El simbolo " + s.getNombre() + " no es un vector");
      }
      else if (rVec.tipo != Tipo_variable.DESCONOCIDO && rVec.tipo != Tipo_variable.ENTERO)
      {
        error_semantico("El tipo del indice del vector debe ser entero");
      }
      else if (rVec.tipo == Tipo_variable.ENTERO && rVec.valorEnt != null)
      {
        if (rVec.valorEnt >= Math.pow(2, 8) || rVec.valorEnt < - Math.pow(2, 8))
        {
          error_semantico("Overflow en el indice del vector");
        }
        if (rVec.valorEnt < 0)
        {
          error_semantico("El indice del vector debe ser positivo");
        }
        if (rVec.valorEnt >= s.getLongitud())
        {
          error_semantico("Se ha intentado acceder a una posicion mayor que la longitud del vector, posicion: " 
          + rVec.valorEnt + " longitud: " + s.getLongitud());
        }
      }
      indice_seleccionado = true;
      generacion_codigo.escribir("PLUS");
    }
    ) ?
    {
      if (s != null)
      {
        if (param != null && param == Clase_parametro.VAL)
        {
          generacion_codigo.escribir("DRF");
          if (s.esVector() && !indice_seleccionado)
          {
            for (int j = 0; j < s.getLongitud(); j++)
            {
              generacion_codigo.escribir("; Posicion " + j + " vector " + s.getNombre());
              generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + (s.getDireccion() + j));
              generacion_codigo.escribir("DRF");
            }
          }
        }
        if (s.esVariable())
        {
          rExpr.parametro = Clase_parametro.REF;
        }
        if (s.esVector() && !indice_seleccionado)
        {
          rExpr.isVector = true;
          rExpr.longitud = s.getLongitud();
        }
      }
      rExpr.simbolo = s;
    }
    // TODO: Comprobar resultado entero (O desconocido), que el resultado no sea mayor que la longitud del vector
    {
      return rExpr;
    }
  | t = < tVALOR_ENTERO >
    {
      rExpr = new RegistroExpr();
      rExpr.valorEnt = Integer.parseInt(t.image);
      rExpr.tipo = Tipo_variable.ENTERO;
      generacion_codigo.escribir("STC " + rExpr.valorEnt);
      return rExpr;
    }
  | t = < tCHAR >
    {
      rExpr = new RegistroExpr();
      rExpr.valorChar = t.image;
      rExpr.tipo = Tipo_variable.CHAR;
      generacion_codigo.escribir("STC " + (int) t.image.charAt(0));
      return rExpr;
    }
  | t = < tTRUE >
    {
      rExpr = new RegistroExpr();
      rExpr.valorBool = true;
      rExpr.tipo = Tipo_variable.BOOLEANO;
      generacion_codigo.escribir("STC 1");
      return rExpr;
    }
  | t = < tFALSE >
    {
      rExpr = new RegistroExpr();
      rExpr.valorBool = false;
      rExpr.tipo = Tipo_variable.BOOLEANO;
      generacion_codigo.escribir("STC 0");
      return rExpr;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return rExpr;
  }
}
