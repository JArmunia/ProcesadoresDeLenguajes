/**
 * Especificaci�n JavaCC para la Pr�ctica 1 (Procesadores de Lenguajes)
 * Javier Fabra - jfabra@unizar.es
 * v1.1 - 2019/02/20
 */

options
{
  static = true;
  ignore_case = true;
}

PARSER_BEGIN(MiniLenguaje)
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import clasesJava.*;
import java.util.ArrayList;
import java.util.Arrays;

public class MiniLenguaje
{
  public static boolean verbose = false;

  public static Tabla_simbolos tabla_simbolos;

  public static GeneracionCodigo generacion_codigo;

  public static int nivel;

  public static final int TBD = - 1;

  public static int dir;

  public static final int DIR_INICIAL = 3;

  public static void main(String args []) throws ParseException, FileNotFoundException
  {
    for (int i = 0; i < args.length; i++)
    {
      if (args [i].equals("-v")) 
      verbose = true;
    }
    //MiniLenguaje parser = new MiniLenguaje(System.in);
    FileInputStream file = null;
    try
    {
      generacion_codigo = GeneracionCodigo.getInstancia(args [1]);
      file = new FileInputStream(args [0] + ".ml");
      MiniLenguaje parser = new MiniLenguaje(file);
    }
    catch (FileNotFoundException e)
    {
      // TODO: Explicar instrucciones de ejecución
      System.err.print("ERROR: No se ha podido encontrar el archivo: " + args [0]);
      System.exit(- 1);
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      // TODO: Explicar instrucciones de ejecución
      System.err.print("ERROR: No se ha especificado un archivo");
      System.exit(- 1);
    }
    try
    {
      MiniLenguaje.programa(verbose);
    }
    catch (ParseException e)
    {
      System.err.println("Desde parse exception");
      System.err.println(e.getMessage());
      //e.printStackTrace();
      //MiniLenguaje.ReInit(System.in);
    }
    catch (Error e)
    {
      e.printStackTrace();
      System.err.println(e.getMessage());
      System.exit(0);
    }
  }

  private static void error_skipto(int kind)
  {
    //ParseException e = generateParseException();
    //System.out.println(e.toString());    
    Token t = token;
    while (t.kind != kind && t.kind != EOF)
    {
      t = getNextToken();
    }
  }

  private static void error_skipto(int kind1, int kind2)
  {
    //ParseException e = generateParseException();
    //System.out.println(e.toString());    
    Token t;
    do
    {
      t = getNextToken();
      System.out.println(t);
    }
    while (t.kind != kind1 && t.kind != kind2 && t.kind != EOF);
  }

  private static void error_sintactico(ParseException e)
  {
    System.err.println("ERROR SINTACTICO: " + e.getMessage());
    generacion_codigo.pararGeneracionCodigo();
    getNextToken();
  }

  private static void error_semantico(Exception e)
  {
    generacion_codigo.pararGeneracionCodigo();
    System.err.println(e);
  }

  private static void error_semantico(String e)
  {
    generacion_codigo.pararGeneracionCodigo();
    System.err.println(new SemanticException(token, e));
  }

  private static RegistroExpr comprobacionExpresion(RegistroExpr r1, RegistroExpr r2, String operador)
  {
    RegistroExpr resultado = new RegistroExpr();
    if ((r1.tipo != Tipo_variable.DESCONOCIDO) && (r2.tipo != Tipo_variable.DESCONOCIDO) && 
    (r1.tipo != r2.tipo))
    {
      error_semantico("Los operandos deben ser del mismo tipo");
      resultado = new RegistroExpr(Tipo_variable.DESCONOCIDO);
    }
    else if ((r1.tipo != Tipo_variable.DESCONOCIDO) && (r2.tipo != Tipo_variable.DESCONOCIDO) && 
    (r1.tipo == r2.tipo))
    {
      resultado = new RegistroExpr(r1, r2, operador);
    }
    return resultado;
  }
}

PARSER_END(MiniLenguaje)

< DEFAULT >
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < [ "%" ] ~[ "%" ] > : COMENT
| < [ "%" ] [ "%" ] > : COMENT_MULTI
}

< COMENT >
SKIP :
{
  "\n" : DEFAULT
}

< COMENT >
MORE :
{
  < ~[ ] >
}

< COMENT_MULTI >
SKIP :
{
  "%%" : DEFAULT
}

< COMENT_MULTI >
MORE :
{
  < ~[ ] >
}

TOKEN : /* PALABRAS RESERVADAS */
{
  < tCLASE : "clase" >
  {
    if (MiniLenguaje.verbose) System.out.println("CLASE");
  }
| < tMETODO : "metodo" >
  {
    if (MiniLenguaje.verbose) System.out.println("METODO");
  }
| < tPROGRAMA : "programa" >
  {
    if (MiniLenguaje.verbose) System.out.println("PROGRAMA");
  }
| < tVAR : "var" >
  {
    if (MiniLenguaje.verbose) System.out.println("VAR");
  }
| < tAND : "and" >
  {
    if (MiniLenguaje.verbose) System.out.println("AND");
  }
| < tOR : "or" >
  {
    if (MiniLenguaje.verbose) System.out.println("OR");
  }
| < tNOT : "not" >
  {
    if (MiniLenguaje.verbose) System.out.println("NOT");
  }
| < tPRINCIPIO : "principio" >
  {
    if (MiniLenguaje.verbose) System.out.println("PRINCIPIO");
  }
| < tFIN : "fin" >
  {
    if (MiniLenguaje.verbose) System.out.println("FIN");
  }
| < tSI : "si" >
  {
    if (MiniLenguaje.verbose) System.out.println("SI");
  }
| < tENT : "ent" >
  {
    if (MiniLenguaje.verbose) System.out.println("ENT");
  }
| < tSI_NO : "si_no" >
  {
    if (MiniLenguaje.verbose) System.out.println("SI_NO");
  }
| < tFSI : "fsi" >
  {
    if (MiniLenguaje.verbose) System.out.println("FSI");
  }
| < tMQ : "mq" >
  {
    if (MiniLenguaje.verbose) System.out.println("MQ");
  }
| < tFMQ : "fmq" >
  {
    if (MiniLenguaje.verbose) System.out.println("FMQ");
  }
| < tESCRIBIR : "escribir" >
  {
    if (MiniLenguaje.verbose) System.out.println("ESCRIBIR");
  }
| < tLEER : "leer" >
  {
    if (MiniLenguaje.verbose) System.out.println("LEER");
  }
| < tMOD : "mod" >
  {
    if (MiniLenguaje.verbose) System.out.println("MOD");
  }
| < tTRUE : "true" >
  {
    if (MiniLenguaje.verbose) System.out.println("TRUE");
  }
| < tFALSE : "false" >
  {
    if (MiniLenguaje.verbose) System.out.println("FALSE");
  }
| < tENTACAR : "entacar" >
  {
    if (MiniLenguaje.verbose) System.out.println("ENTACAR");
  }
| < tCARAENT : "caraent" >
  {
    if (MiniLenguaje.verbose) System.out.println("CARAENT");
  }
| < tACCION : "accion" >
  {
    if (MiniLenguaje.verbose) System.out.println("ACCION");
  }
| < tVAL : "val" >
  {
    if (MiniLenguaje.verbose) System.out.println("VAL");
  }
| < tREF : "ref" >
  {
    if (MiniLenguaje.verbose) System.out.println("REF");
  }
}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    if (MiniLenguaje.verbose) System.out.println("ENTERO");
  }
| < tDECIMAL : "decimal" >
  {
    if (MiniLenguaje.verbose) System.out.println("DECIMAL");
  }
| < tBOOLEANO : "booleano" >
  {
    if (MiniLenguaje.verbose) System.out.println("BOOLEANO");
  }
| < tCARACTER : "caracter" >
  {
    if (MiniLenguaje.verbose) System.out.println("CARACTER");
  }
}

TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    if (MiniLenguaje.verbose) System.out.println("LLAVE_IZQ");
  }
| < tLLAVE_DCHA : "}" >
  {
    if (MiniLenguaje.verbose) System.out.println("LLAVE_DCHA");
  }
| < tPARENTESIS_IZQ : "(" >
  {
    if (MiniLenguaje.verbose) System.out.println("PARENTESIS_IZQ");
  }
| < tPARENTESIS_DCHA : ")" >
  {
    if (MiniLenguaje.verbose) System.out.println("PARENTESIS_DCHA");
  }
| < tCORCHETE_IZQ : "[" >
  {
    if (MiniLenguaje.verbose) System.out.println("CORCHETE_IZQ");
  }
| < tCORCHETE_DCHA : "]" >
  {
    if (MiniLenguaje.verbose) System.out.println("CORCHETE_DCHA");
  }
}

TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    if (MiniLenguaje.verbose) System.out.println("OPAS");
  }
| < tIGUAL : "=" >
  {
    if (MiniLenguaje.verbose) System.out.println("IGUAL");
  }
| < tFIN_SENTENCIA : ";" >
  {
    if (MiniLenguaje.verbose) System.out.println("FIN_SENTENCIA");
  }
| < tCOMA : "," >
  {
    if (MiniLenguaje.verbose) System.out.println("COMA");
  }
| < tMAS : "+" >
  {
    if (MiniLenguaje.verbose) System.out.println("MAS");
  }
| < tMENOS : "-" >
  {
    if (MiniLenguaje.verbose) System.out.println("MENOS");
  }
| < tPOR : "*" >
  {
    if (MiniLenguaje.verbose) System.out.println("POR");
  }
| < tDIV :
    "/"
  | "div" >
  {
    if (MiniLenguaje.verbose) System.out.println("DIV");
  }
| < tMAI : ">=" >
  {
    if (MiniLenguaje.verbose) System.out.println("MAYOR O IGUAL");
  }
| < tMEI : "<=" >
  {
    if (MiniLenguaje.verbose) System.out.println("MENOR O IGUAL");
  }
| < tNI : "<>" >
  {
    if (MiniLenguaje.verbose) System.out.println("NI");
  }
| < tMAYOR : ">" >
  {
    if (MiniLenguaje.verbose) System.out.println("MAYOR");
  }
| < tMENOR : "<" >
  {
    if (MiniLenguaje.verbose) System.out.println("MENOR");
  }
}

SKIP :
{
  "\"" : STRING
}

< STRING >
SKIP :
{
  < "\"" > 
  : DEFAULT
}

< STRING >
TOKEN :
{
  < tCHAR : (~[ "\"" ]) >
  {
    if (MiniLenguaje.verbose) System.out.println("CHAR (Valor: " + matchedToken + ")");
  }
}

< STRING >
TOKEN :
{
  < tSTRING : (~[ "\"" ])+ >
  {
    if (MiniLenguaje.verbose) System.out.println("STRING (Valor: " + matchedToken + ")");
  }
}

TOKEN : /* VALORES */
{
  < tIDENTIFICADOR :
    ([ "a"-"z", "_" ]) ([ "a"-"z", "_", "0"-"9" ])* ([ "a"-"z", "0"-"9" ])
  | ([ "a"-"z", "_" ]) >
  {
    if (MiniLenguaje.verbose) System.out.println("IDENTIFICADOR (Valor: " + matchedToken + ")");
  }
| < tVALOR_ENTERO : ([ "0"-"9" ])+ >
  {
    if (MiniLenguaje.verbose) System.out.println("VALOR_ENTERO (Valor: " + matchedToken + ")");
  }
| < tVALOR_DECIMAL : ([ "0"-"9" ])+ "." ([ "0"-"9" ])+ >
  {
    if (MiniLenguaje.verbose) System.out.println("VALOR_DECIMAL (Valor: " + matchedToken + ")");
  }
}

/************************************
************* PROGRAMA **************
*************************************/

// <tPROGRAMA> <tIDENTIFICADOR> <tFIN_SENTENCIA> declaracion_variables() declaracion_acciones() bloque_sentencias()
void programa(boolean verbose) :
{}
{
  {
    tabla_simbolos = Tabla_simbolos.inicializar_tabla(31);
    nivel = 0;
    dir = DIR_INICIAL;
    String etiq;
    Token t;
  }
  < tPROGRAMA > t = < tIDENTIFICADOR >
  {
    tabla_simbolos.introducir_programa(t.image, TBD);
    etiq = generacion_codigo.getEtiqueta();
    generacion_codigo.escribir("; Programa " + t.image);
    generacion_codigo.escribir("ENP " + etiq);
  }
  < tFIN_SENTENCIA > 
  declaracion_variables()
  {
  //System.out.println("Fin de declaracion de variables");
  }
  declaracion_acciones()
  {
    //System.out.println("Fin de declaracion de acciones");
    generacion_codigo.escribir("; Comienzo de " + t.image);
    generacion_codigo.escribir(etiq + ":");
  }
  bloque_sentencias()
  {
    tabla_simbolos.eliminar_programa();
    generacion_codigo.escribir("; Fin de " + t.image);
    generacion_codigo.escribir("LVP");
    generacion_codigo.escribirPrograma();
    //System.out.println("Fin de " + t.image);
  }
  < EOF >
}

// (declaracion()<tFIN_SENTENCIA>)*
void declaracion_variables() :
{}
{
  (
    try
    {
      declaracion() < tFIN_SENTENCIA >
    }
    catch (ParseException e)
    {
      error_sintactico(e);
      declaracion_variables();
    }
  )*
}

// tipo_variables() identificadores()
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList < String > identificadores;
}
{
  try
  {
    tipo = tipo_variables() 
    identificadores = identificadores()
    {
      for (String identificador : identificadores)
      {
        if (tabla_simbolos.introducir_variable(identificador, tipo, nivel, dir++) == null)
        {
          error_semantico(new ExcepcionTablaSimbolos(identificador, token.beginLine, nivel, tabla_simbolos.buscar_simbolo(identificador)));
        }
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tENTERO> | <tCARACTER> | <tBOOLEANO> | <tDECIMAL>
Tipo_variable tipo_variables() :
{}
{
  < tENTERO >
  {
    return Tipo_variable.ENTERO;
  }
| < tCARACTER >
  {
    return Tipo_variable.CHAR;
  }
| < tBOOLEANO >
  {
    return Tipo_variable.BOOLEANO;
  }
| < tDECIMAL >
  {
    return Tipo_variable.DECIMAL;
  }
}

// <tIDENTIFICADOR>(<tCOMA><tIDENTIFICADOR>)*
ArrayList < String > identificadores() :
{
  ArrayList < String > identificadores = new ArrayList();
}
{
  try
  {
    < tIDENTIFICADOR >
    {
      identificadores.add(token.image);
    }
    (
    < tCOMA > < tIDENTIFICADOR >
    {
      identificadores.add(token.image);
    }
    ) *
    {
      return identificadores;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return identificadores;
  }
}

// (declaracion_accion())*
void declaracion_acciones() :
{}
{
  (
    try
    {
      declaracion_accion()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
      declaracion_acciones();
    }
  )*
}

// cabecera_accion() <tFIN_SENTENCIA> declaracion_variables() declaracion_acciones() bloque_sentencias()
void declaracion_accion() :
{
  int dir_prev = dir;
  dir = DIR_INICIAL;
  String etiq;
  Token t;
}
{
  try
  {
    t = cabecera_accion()
    {
      etiq = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("JMP " + etiq);
    }
    < tFIN_SENTENCIA > 
    declaracion_variables() 
    declaracion_acciones()
    {
      generacion_codigo.escribir("; Codigo accion " + t.image);
      generacion_codigo.escribir(etiq + ":");
    }
    bloque_sentencias()
    {
      generacion_codigo.escribir("CSF ");
      generacion_codigo.escribir("; Fin accion " + t.image);
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tACCION> <tIDENTIFICADOR> parametros_formales()
Token cabecera_accion() :
{
  ArrayList < Simbolo > parametros;
  Simbolo accion, s;
  Boolean buscarParametros = true;
  Token t;
}
{
  try
  {
    < tACCION > t = < tIDENTIFICADOR >
    {
      generacion_codigo.escribir("; Declaraciones accion " + t.image);
      accion = tabla_simbolos.introducir_accion(t.image, nivel, dir);
      if (accion == null)
      {
        error_semantico(new ExcepcionTablaSimbolos(t, nivel, tabla_simbolos.buscar_simbolo(token.image)));
        buscarParametros = false;
      }
      nivel++;
      //System.out.println("Aumenta nivel accion: " + accion.getNombre() + " nivel: " + nivel);
    }
    parametros = parametros_formales()
    {
      if (buscarParametros)
      {
        for (Simbolo parametro : parametros)
        {
          accion.introducir_parametro(parametro);
        }
        generacion_codigo.escribir("; Parametros accion " + t.image);
        for (int i = parametros.size() - 1; i >= 0; i--)
        {
          s = parametros.get(i);
          generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
          generacion_codigo.escribir("ASGI");
        }
      }
      return t;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// ((<tPARENTESIS_IZQ> parametros()) (<tFIN_SENTENCIA> parametros())* <tPARENTESIS_DCHA>)? 
ArrayList < Simbolo > parametros_formales() :
{
  if (MiniLenguaje.verbose) System.out.println("Parametros formales \n");
  ArrayList < Simbolo > parametros = new ArrayList < Simbolo > ();
  ArrayList < Simbolo > masParametros;
}
{
  try
  {
    (
    (
    < tPARENTESIS_IZQ > parametros = parametros()
    ) 
    (
    < tFIN_SENTENCIA > masParametros = parametros()
    {
      parametros.addAll(masParametros);
    }
    ) * 
    < tPARENTESIS_DCHA >
    ) ?
    {
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < Simbolo > lista_parametros(Clase_parametro clase, Tipo_variable tipo) :
{
  ArrayList < String > identificadores;
  ArrayList < Simbolo > parametros = new ArrayList();
  Simbolo parametro;
}
{
  try
  {
    identificadores = identificadores()
    {
      for (String identificador : identificadores)
      {
        parametro = tabla_simbolos.introducir_parametro(identificador, tipo, clase, nivel, dir++);
        if (parametro == null)
        {
          error_semantico(new ExcepcionTablaSimbolos(identificador, token.beginLine, nivel, tabla_simbolos.buscar_simbolo(identificador)));
        }
        else
        {
          parametros.add(parametro);
        }
      }
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// clase_parametros() tipo_variables() lista_parametros()
ArrayList < Simbolo > parametros() :
{
  Clase_parametro clase;
  Tipo_variable tipo;
  ArrayList < Simbolo > parametros = new ArrayList();
}
{
  try
  {
    clase = clase_parametros() 
    tipo = tipo_variables() 
    parametros = lista_parametros(clase, tipo)
    {
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// <tVAL> | <tREF>
Clase_parametro clase_parametros() :
{}
{
  < tVAL >
  {
    return Clase_parametro.VAL;
  }
| < tREF >
  {
    return Clase_parametro.REF;
  }
}

// <tPRINCIPIO> lista_sentencias() <tFIN>
void bloque_sentencias() :
{}
{
  try
  {
    < tPRINCIPIO > lista_sentencias() < tFIN >
    {
      //System.out.println("######################################################################################");    
      //System.out.println("Tabla antes de borrar nivel " + nivel);
      //System.out.println(tabla_simbolos);
      tabla_simbolos.ocultar_parametros(nivel);
      tabla_simbolos.eliminar_variables(nivel);
      // Elimino los parámetros ocultos al eliminar las acciones
      tabla_simbolos.eliminar_acciones(nivel);
      nivel--;
      //System.out.println("\nTabla despues de borrar nivel " + (nivel + 1));
      //System.out.println(tabla_simbolos);
      //System.out.println("######################################################################################");
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    lista_sentencias();
  }
}

// (sentencia())* 
void lista_sentencias() :
{}
{
  (
    try
    {
      sentencia()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
  )+
}

/*
leer()  < tFIN_SENTENCIA >|
  escribir() < tFIN_SENTENCIA >|
  < tIDENTIFICADOR > [asignacion() |  invocacion_accion() ] < tFIN_SENTENCIA > |
  seleccion()  |
  mientras_que()
  */
void sentencia() :
{
  Token identificador;
}
{
  try
  {
    leer() < tFIN_SENTENCIA >
  | 
    escribir() < tFIN_SENTENCIA >
  | 
    identificador = < tIDENTIFICADOR >
    [
      asignacion(identificador)
    | invocacion_accion(identificador)
    ]
  | 
    seleccion()
  | 
    mientras_que()
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tLEER> <tPARENTESIS_IZQ> lista_asignables() <tPARENTESIS_DCHA>
void leer() :
{
  ArrayList < Token > asignables = new ArrayList();
  Simbolo s;
}
{
  try
  {
    < tLEER > < tPARENTESIS_IZQ > asignables = lista_asignables() < tPARENTESIS_DCHA >
    {
      for (Token t : asignables)
      {
        s = tabla_simbolos.buscar_simbolo(t.image);
        if (s == null)
        {
          error_semantico("Identificador desconocido: " + t.image);
          tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, nivel, TBD);			
        }
        else if (s.getTipoSimbolo() == Tipo_simbolo.ACCION)
        {
          error_semantico("No se puede asignar el simbolo " + t.image + " ya que es una accion");
        }
        else if (s.getVariable() != Tipo_variable.CHAR 
        && s.getVariable() != Tipo_variable.ENTERO 
        && s.getVariable() != Tipo_variable.DESCONOCIDO)
        {
          error_semantico("No se puede asignar la variable " + t.image + " ya que es de tipo " + s.getVariable());
        }
        else if (s.esParametro() && s.esValor())
        {
          error_semantico("No se puede asignar " + t.image + " ya que es un parametro por valor");
        }
        // Generacion codigo
        if (s != null && !s.esAccion())
        {
          generacion_codigo.escribir("; Leer");
          generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
          if (s.esParametro() && s.esReferencia())
          {
            generacion_codigo.escribir("DRF");
          }
          else if (s.esChar())
          {
            generacion_codigo.escribir("RD 0");
          }
          else
          {
            generacion_codigo.escribir("RD 1");
          }
        }
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tIDENTIFICADOR> (<tCOMA> <tIDENTIFICADOR>)*
ArrayList < Token > lista_asignables() :
{
  ArrayList < Token > asignables = new ArrayList();
  Token t;
}
{
  try
  {
    t = < tIDENTIFICADOR >
    {
      asignables.add(t);
    }
    (< tCOMA > t = < tIDENTIFICADOR >
    {
      asignables.add(t);
    }
    ) *
    {
      return asignables;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return asignables;
  }
}

// <tESCRIBIR> <tPARENTESIS_IZQ> lista_escribibles() <tPARENTESIS_DCHA>
void escribir() :
{
  ArrayList < RegistroExpr > escribibles = new ArrayList();
}
{
  try
  {
    < tESCRIBIR > < tPARENTESIS_IZQ >
    {
      generacion_codigo.escribir("; Escribir ");
    }
    escribibles = lista_escribibles() < tPARENTESIS_DCHA >
    {
      //System.out.println("Escribibles en la linea: " + token.beginLine);
      //System.out.println(Arrays.toString(escribibles.toArray()));
      for (RegistroExpr r : escribibles)
      {
      //System.out.println(r.valorChar);
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < RegistroExpr > lista_escribibles() :
{
  ArrayList < RegistroExpr > escribibles = new ArrayList();
  RegistroExpr r, resultado;
  Token string;
}
{
  //TODO: Pasar registrosexpr con la cadena que representa a cada valor que se pasa
  try
  {
    (r = expresion()
    {
      if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool)
        {
          resultado = new RegistroExpr("Verdadero");
        }
        else
        {
          resultado = new RegistroExpr("False");
        }
      }
      else if (r.tipo == Tipo_variable.ENTERO && r.valorEnt != null)
      {
        resultado = new RegistroExpr("" + r.valorEnt);
      }
      else // Si es de tipo char, entero, desconocido o un booleano con valor nulo, no hacen falta transformaciones
      {
        resultado = new RegistroExpr("" + r.valorChar);
      }
      escribibles.add(resultado);
      // Generacion codigo
      if (r.tipo == Tipo_variable.ENTERO)
      {
        generacion_codigo.escribir("WRT 1");
      }
      else if (r.tipo == Tipo_variable.CHAR)
      {
        generacion_codigo.escribir("WRT 0");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO)
      {
        generacion_codigo.escribir("WRT 1"); // TODO: Poner que escriba verdadero y falso
      }
    }
  | string = < tSTRING >
    {
      resultado = new RegistroExpr(string.image);
      escribibles.add(resultado);
      generacion_codigo.escribir("; " + resultado.valorChar);
      for (int i = 0; i < resultado.valorChar.length(); i++)
      {
        generacion_codigo.escribir("STC " + (int) resultado.valorChar.charAt(i));
        generacion_codigo.escribir("WRT 0");
      }
    }
    ) 
    (
    < tCOMA > 
    (r = expresion()
    {
      if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool)
        {
          resultado = new RegistroExpr("Verdadero");
        }
        else
        {
          resultado = new RegistroExpr("False");
        }
      }
      else if (r.tipo == Tipo_variable.ENTERO && r.valorEnt != null)
      {
        resultado = new RegistroExpr("" + r.valorEnt);
      }
      else // Si es de tipo char, entero, desconocido o un booleano con valor nulo, no hacen falta transformaciones
      {
        resultado = new RegistroExpr("" + r.valorChar);
      }
      escribibles.add(resultado);
      // Generacion codigo
      if (r.tipo == Tipo_variable.ENTERO)
      {
        generacion_codigo.escribir("WRT 1");
      }
      else if (r.tipo == Tipo_variable.CHAR)
      {
        generacion_codigo.escribir("WRT 0");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO)
      {
        generacion_codigo.escribir("WRT 1"); // TODO: Poner que escriba verdadero y falso
      }
    }
  | string = < tSTRING >
    {
      resultado = new RegistroExpr(string.image);
      escribibles.add(resultado);
      generacion_codigo.escribir("; " + resultado.valorChar);
      for (int i = 0; i < resultado.valorChar.length(); i++)
      {
        generacion_codigo.escribir("STC " + (int) resultado.valorChar.charAt(i));
        generacion_codigo.escribir("WRT 0");
      }
    }
    )
    ) *
    {
      return escribibles;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return escribibles;
  }
}

// <tOPAS> expresion() 
void asignacion(Token t) :
{
  Simbolo s;
  RegistroExpr r;
  Tipo_variable tipoID;
}
{
  try
  {
    {
      s = tabla_simbolos.buscar_simbolo(t.image);
      if (s == null)
      {
        error_semantico("Identificador desconocido en la parte izquierda de la asignacion: " + t.image);
        tipoID = Tipo_variable.DESCONOCIDO;
        tabla_simbolos.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, nivel, TBD);
      }
      else
      {
        if (s.esParametro() && s.esValor())
        {
          error_semantico("No se puede realizar una asignacion a un parametro por valor");
        }
        else if (s.esAccion())
        {
          error_semantico("No se puede realizar una asignacion a una accion");
        }
        tipoID = s.getVariable();
        generacion_codigo.escribir("; Asignacion de " + t.image);
        generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
        if (s.esParametro() && s.esReferencia())
        {
          generacion_codigo.escribir("DRF");
        }
      }
    }
    < tOPAS > r = expresion()
    {
      if ((tipoID != Tipo_variable.DESCONOCIDO) && (r.tipo != Tipo_variable.DESCONOCIDO) && (tipoID != r.tipo))
      {
        error_semantico("Tipos incompatibles en la asignacion");
      }
      generacion_codigo.escribir("ASG");
    }
    < tFIN_SENTENCIA >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// argumentos() 
void invocacion_accion(Token t) :
{
  Simbolo accion, paramOriginal;
  ArrayList < RegistroExpr > args = new ArrayList();
  RegistroExpr param;
}
{
  try
  {
    (
    args = argumentos()) ? < tFIN_SENTENCIA >
    {
      accion = tabla_simbolos.buscar_simbolo(t.image);
      if (accion == null)
      {
        error_semantico("Identificador de accion desconocido: " + t.image);
        accion = tabla_simbolos.introducir_accion(t.image, nivel, TBD);
        accion.setVariable(Tipo_variable.DESCONOCIDO);			
      }
      else if (!accion.esAccion())
      {
        error_semantico(t.image + " no es una accion");
      }
      else if (accion.getVariable() != Tipo_variable.DESCONOCIDO)
      {
        if (args.size() != accion.getListaParametros().size())
        {
          error_semantico("El numero de parametros no coincide con el de la accion " + 
          t.image + ", se han proporcionado " + args.size() + " pero se requieren " + accion.getListaParametros().size());
        }
        else
        {
          for (int i = 0; i < args.size(); i++)
          {
            // TODO: Comprobar tipo de los parametros
            paramOriginal = accion.getListaParametros().get(i);
            param = args.get(i);
            //System.out.println(Arrays.toString(args.toArray()));
            //System.out.println(param + " accion: " + accion.getNombre() + " parametro: " + paramOriginal);
            if (paramOriginal.getVariable() != param.tipo 
            && param.tipo != Tipo_variable.DESCONOCIDO)
            {
              error_semantico("El tipo del parametro en la posicion " + i + 
              " no coincide, deberia ser " + paramOriginal.getVariable() + 
              " pero es " + param.tipo + " en la accion " + accion.getNombre());
            }
            if (paramOriginal.getParametro() == Clase_parametro.REF 
            && param.parametro != Clase_parametro.REF)
            {
              error_semantico("El parametro en la posicion " + i + 
              " deberia ser un parametro por referencia, pero se ha pasado un parametro por valor" + " en la accion " + accion.getNombre());
              System.out.println(tabla_simbolos);
            }
          }
        }
        generacion_codigo.escribir("OSF " + (dir - 1) + " " + (nivel - accion.getNivel()) + " L" + accion.getDireccion());
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tMQ> expresion() lista_sentencias() <tFMQ>
void mientras_que() :
{
  RegistroExpr r;
  String etiqMQ, etiqFin;
}
{
  try
  {
    < tMQ >
    {
      etiqMQ = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir(etiqMQ + ":");
    }
    r = expresion()
    {
      etiqFin = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("; Mq");
      generacion_codigo.escribir("JMF " + etiqFin);
      if (r.tipo != Tipo_variable.DESCONOCIDO && r.tipo != Tipo_variable.BOOLEANO)
      {
        error_semantico("La condicion en el mientras_que debe ser un booleano");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool == true)
        {
          error_semantico("Bucle infinito");
        }
        else
        {
          error_semantico("Nunca se entra en el bucle");
        }
      }
    }
    lista_sentencias() < tFMQ >
    {
      generacion_codigo.escribir("JMP " + etiqMQ);
      generacion_codigo.escribir(etiqFin + ":");
      generacion_codigo.escribir("; Fin mq");	
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tSI> expresion() <tENT> lista_sentencias() (<tSI_NO> lista_sentencias())?  <tFSI>
void seleccion() :
{
  RegistroExpr r;
  String etiqSINO, etiqFin;
}
{
  try
  {
    < tSI > r = expresion()
    {
      etiqSINO = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("; Si");
      generacion_codigo.escribir("JMF " + etiqSINO);
      if (r.tipo != Tipo_variable.DESCONOCIDO && r.tipo != Tipo_variable.BOOLEANO)
      {
        error_semantico("La condicien la seleccion debe ser un booleano");
      }
      else if (r.tipo == Tipo_variable.BOOLEANO && r.valorBool != null)
      {
        if (r.valorBool == true)
        {
          error_semantico("La condicion es siempre cierta");
        }
        else
        {
          error_semantico("La condicion nunca es cierta");
        }
      }
    }
    < tENT > lista_sentencias()
    {
      etiqFin = generacion_codigo.getEtiqueta();
      generacion_codigo.escribir("JMP " + etiqFin);
      generacion_codigo.escribir("; Si no");
      generacion_codigo.escribir(etiqSINO + ":");
    }
    (
    < tSI_NO > lista_sentencias()
    ) ? 
    < tFSI >
    {
      generacion_codigo.escribir(etiqFin + ":");
      generacion_codigo.escribir("; Fin si");
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tPARENTESIS_IZQ> (lista_expresiones())? <tPARENTESIS_DCHA>
ArrayList < RegistroExpr > argumentos() :
{
  ArrayList < RegistroExpr > args = new ArrayList();
}
{
  try
  {
    < tPARENTESIS_IZQ > 
    (
    args = lista_expresiones()
    ) ? 
    < tPARENTESIS_DCHA >
    {
      return args;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return args;
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < RegistroExpr > lista_expresiones() :
{
  ArrayList < RegistroExpr > args = new ArrayList();
  RegistroExpr r;
}
{
  try
  {
    r = expresion()
    {
      args.add(r);
    }
    (
    < tCOMA > r = expresion()
    {
      args.add(r);
    }
    ) *
    {
      return args;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return args;
  }
}

// expresion_simple() (operador_relacional() expresion_simple())*
RegistroExpr expresion() :
{
  RegistroExpr r1, r2;
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = expresion_simple() 
    (
    token_operador = operador_relacional() 
    r2 = expresion_simple()
    {
      operador = token_operador.image;
      r1 = comprobacionExpresion(r1, r2, operador);
      switch (operador)
      {
        case "=" : 
        generacion_codigo.escribir("EQ");
        break;
        case "<>" : 
        generacion_codigo.escribir("NEQ");
        break;
        case "<" : 
        generacion_codigo.escribir("LT");
        break;
        case "<=" : 
        generacion_codigo.escribir("LTE");
        break;
        case ">" : 
        generacion_codigo.escribir("GT");
        break;
        case ">=" : 
        generacion_codigo.escribir("GTE");
        break;
      }
    }
    ) ?
    {
      //System.out.println(r1);
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tMAYOR> | <tMENOR> | <tMAI> | <tMEI> | <tNI> | <tIGUAL>
Token operador_relacional() :
{
  Token t;
}
{
  t = < tMAYOR >
  {
    return t;
  }
| t = < tMENOR >
  {
    return t;
  }
| t = < tMAI >
  {
    return t;
  }
| t = < tMEI >
  {
    return t;
  }
| t = < tNI >
  {
    return t;
  }
| t = < tIGUAL >
  {
    return t;
  }
}

// termino() (operador_aditivo() termino())*
RegistroExpr expresion_simple() :
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = termino() 
    (
    token_operador = operador_aditivo() 
    r2 = termino()
    {
      operador = token_operador.image;
      switch (operador)
      {
        case "+" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= Math.pow(2, 16) || r1.valorEnt < (- Math.pow(2, 16))))
          {
            error_semantico("Error de overflow/underflow al realizar la suma.");
            r1.valorEnt = null;
          }
        }
        generacion_codigo.escribir("PLUS");
        break;
        case "-" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= Math.pow(2, 16) || r1.valorEnt < (- Math.pow(2, 16))))
          {
            error_semantico("Error de overflow/underflow al realizar la resta.");
            r1.valorEnt = null;
          }
        }
        generacion_codigo.escribir("SBT");
        break;
        case "or" : 
        if ((r1.tipo != Tipo_variable.BOOLEANO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.BOOLEANO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba booleano.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);				
        }
        generacion_codigo.escribir("OR");
        break;
      }
    }
    ) *
    {
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return r1;
  }
}

// <tMAS> | <tMENOS> | <tOR>
Token operador_aditivo() :
{
  Token t;
}
{
  t = < tMAS >
  {
    return t;
  }
| t = < tMENOS >
  {
    return t;
  }
| t = < tOR >
  {
    return t;
  }
}

// factor() (operador_multiplicativo() factor())* 
RegistroExpr termino() :
{
  RegistroExpr r1 = new RegistroExpr(), r2 = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = factor() 
    (
    token_operador = operador_multiplicativo() 
    r2 = factor()
    {
      operador = token_operador.image;
      switch (operador)
      {
        case "*" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= Math.pow(2, 16) || r1.valorEnt < (- Math.pow(2, 16))))
          {
            error_semantico("Error de overflow/underflow al realizar la multiplicacion.");
            r1.valorEnt = null;
          }
        }
        generacion_codigo.escribir("TMS");
        break;
        case "div" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Division por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        generacion_codigo.escribir("DIV");
        break;
        case "/" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Division por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        generacion_codigo.escribir("DIV");
        break;
        case "mod" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Modulo por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        generacion_codigo.escribir("MOD");
        break;
        case "and" : 
        if ((r1.tipo != Tipo_variable.BOOLEANO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.BOOLEANO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba booleano.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {				
          r1 = new RegistroExpr(r1, r2, operador);						
        }
        generacion_codigo.escribir("AND");
        break;			
      }
    }
    ) *
    {
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return r1;
  }
}

// <tPOR> | <tDIV> | <tMOD> | <tAND>
Token operador_multiplicativo() :
{
  Token t;
}
{
  t = < tPOR >
  {
    return t;
  }
| t = < tDIV >
  {
    return t;
  }
| t = < tMOD >
  {
    return t;
  }
| t = < tAND >
  {
    return t;
  }
}

/*
	< tMENOS > factor()
| < tNOT > factor()
| < tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tENTACAR > <tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tCARAENT > <tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tIDENTIFICADOR >
| < tVALOR_ENTERO >
| < tVALOR_DECIMAL >
| < tSTRING >
| < tTRUE >
| < tFALSE >
*/
RegistroExpr factor() :
{
  RegistroExpr rExpr = new RegistroExpr();
  Token t;
  Simbolo s;
}
{
  try
  {
    < tMENOS > rExpr = factor()
    {
      if ((rExpr.tipo != Tipo_variable.ENTERO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.ENTERO));
        rExpr.tipo = Tipo_variable.ENTERO;
      }
      if (rExpr.valorEnt != null)
      {
        rExpr.valorEnt = - rExpr.valorEnt;
      }
      generacion_codigo.escribir("NGI");
      return rExpr;
    }
  | < tNOT > rExpr = factor()
    {
      if ((rExpr.tipo != Tipo_variable.BOOLEANO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.BOOLEANO));
        rExpr.tipo = Tipo_variable.BOOLEANO;
      }
      if (rExpr.valorBool != null)
      {
        rExpr.valorBool = !rExpr.valorBool;
      }
      generacion_codigo.escribir("NGB");
      return rExpr;
    }
  | < tPARENTESIS_IZQ > rExpr = expresion() < tPARENTESIS_DCHA >
    {
      return rExpr;
    }
  | < tENTACAR > < tPARENTESIS_IZQ > rExpr = expresion() < tPARENTESIS_DCHA >
    {
      if ((rExpr.tipo != Tipo_variable.ENTERO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.ENTERO));
      }
      if ((rExpr.valorEnt != null) && ((rExpr.valorEnt > 255) || (rExpr.valorEnt < 0)))
      {
        error_semantico("La expresion no se puede convertir en un caracter valido");
      }
      rExpr.tipo = Tipo_variable.CHAR;
      return rExpr;
    }
  | < tCARAENT > < tPARENTESIS_IZQ > rExpr = expresion() < tPARENTESIS_DCHA >
    {
      if ((rExpr.tipo != Tipo_variable.CHAR) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.CHAR));
      }
      rExpr.tipo = Tipo_variable.ENTERO;
      return rExpr;
    }
  | t = < tIDENTIFICADOR >
    {
      s = tabla_simbolos.buscar_simbolo(t.image);
      rExpr = new RegistroExpr();
      if (s == null)
      {
        error_semantico("Identificador desconocido: " + t.image);
        s = tabla_simbolos.introducir_variable(token.image, Tipo_variable.DESCONOCIDO, nivel, TBD);	
        rExpr.tipo = Tipo_variable.DESCONOCIDO;
      }
      else if (s.esAccion())
      {
        error_semantico("No se puede utilizar una accion como expresion");
      }
      else
      {
        generacion_codigo.escribir("; Variable " + t.image);
        generacion_codigo.escribir("SRF " + (nivel - s.getNivel()) + " " + s.getDireccion());
        rExpr.tipo = s.getVariable();
        if (s.esParametro())
        {
          rExpr.parametro = s.getParametro();
          if (s.esReferencia())
          {
            generacion_codigo.escribir("DRF");
          }
        }
        if (s.esValor())
        {
          generacion_codigo.escribir("DRF");
        }
        else if (s.esVariable())
        {
          rExpr.parametro = Clase_parametro.REF;
        }
      }
      return rExpr;	
    }
  | t = < tVALOR_ENTERO >
    {
      rExpr = new RegistroExpr();
      rExpr.valorEnt = Integer.parseInt(t.image);
      rExpr.tipo = Tipo_variable.ENTERO;
      generacion_codigo.escribir("STC " + rExpr.valorEnt);
      return rExpr;
    }
  | t = < tCHAR >
    {
      rExpr = new RegistroExpr();
      rExpr.valorChar = t.image;
      rExpr.tipo = Tipo_variable.CHAR;
      generacion_codigo.escribir("STC " + (int) t.image.charAt(0));
      return rExpr;
    }
    /*| t = < tSTRING >
    {
      rExpr = new RegistroExpr();
      rExpr.valorChar = t.image;
      rExpr.tipo = Tipo_variable.CHAR;
      return rExpr;
    }*/
  | t = < tTRUE >
    {
      rExpr = new RegistroExpr();
      rExpr.valorBool = true;
      rExpr.tipo = Tipo_variable.BOOLEANO;
      generacion_codigo.escribir("STC 1");
      return rExpr;
    }
  | t = < tFALSE >
    {
      rExpr = new RegistroExpr();
      rExpr.valorBool = false;
      rExpr.tipo = Tipo_variable.BOOLEANO;
      generacion_codigo.escribir("STC 0");
      return rExpr;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return rExpr;
  }
}
