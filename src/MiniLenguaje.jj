/**
 * Especificaci�n JavaCC para la Pr�ctica 1 (Procesadores de Lenguajes)
 * Javier Fabra - jfabra@unizar.es
 * v1.1 - 2019/02/20
 */

options
{
  static = true;
  ignore_case = true;
}

PARSER_BEGIN(MiniLenguaje)
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import ClasesJava.*;
import java.util.ArrayList;

public class MiniLenguaje
{
  public static boolean verbose = false;

  public static Tabla_simbolos tabla_simbolos;

  public static int nivel;

  public static final int TBD = - 1;

  public static void main(String args []) throws ParseException, FileNotFoundException
  {
    for (int i = 0; i < args.length; i++)
    {
      if (args [i].equals("-v")) 
      verbose = true;
    }
    //MiniLenguaje parser = new MiniLenguaje(System.in);
    FileInputStream file = null;
    try
    {
      file = new FileInputStream(args [0]);
      MiniLenguaje parser = new MiniLenguaje(file);
    }
    catch (FileNotFoundException e)
    {
      // TODO: Explicar instrucciones de ejecución
      System.err.print("ERROR: No se ha podido encontrar el archivo: " + args [0]);
      System.exit(- 1);
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      // TODO: Explicar instrucciones de ejecución
      System.err.print("ERROR: No se ha especificado un archivo");
      System.exit(- 1);
    }
    try
    {
      MiniLenguaje.programa(verbose);
    }
    catch (ParseException e)
    {
      System.err.println(e.getMessage());
      //MiniLenguaje.ReInit(System.in);
    }
    catch (Error e)
    {
      e.printStackTrace();
      System.err.println(e.getMessage());
      System.exit(0);
    }
  }

  /**
* Código obtenido de https://stackoverflow.com/questions/29127861/dont-stop-parsing-after-first-exception
*/
  private static void error_skipto(int kind)
  {
    //ParseException e = generateParseException();
    //System.out.println(e.toString());    
    Token t;
    do
    {
      t = getNextToken();
      System.out.println(t);
    }
    while (t.kind != kind);
  }

  private static void error_skipto(int kind1, int kind2)
  {
    //ParseException e = generateParseException();
    //System.out.println(e.toString());    
    Token t;
    do
    {
      t = getNextToken();
      System.out.println(t);
    }
    while (t.kind != kind1 || t.kind != kind2);
  }

  private static void error_sintactico(ParseException e)
  {
    //error_sintactico(e, "");
    System.err.println("ERROR SINTACTICO: " + e.getMessage());
    //Token lastRead = MiniLenguaje.getNextToken();
    error_skipto(tFIN_SENTENCIA, tFIN);
  }

  private static void error_sintactico(ParseException e, String msg)
  {
    //correcto = false;
    //Token lastRead = MiniLenguaje.getNextToken();
    //System.err.println("ERROR SINTACTICO (<" + lastRead.beginLine + ", " + 
    //lastRead.beginColumn + ">) : <Simbolo obtenido: '" + lastRead.image + 
    //"'. " + msg + ">");
  }

  private static void error_semantico(Exception e)
  {
    System.err.println(e);
  }

  private static void error_semantico(String e)
  {
    System.err.println(new SemanticException(token, e));
  }

  private static RegistroExpr comprobacionExpresion(RegistroExpr r1, RegistroExpr r2, String operador)
  {
    RegistroExpr resultado = new RegistroExpr();
    if ((r1.tipo != Tipo_variable.DESCONOCIDO) && (r2.tipo != Tipo_variable.DESCONOCIDO) && 
    (r1.tipo != r2.tipo))
    {
      error_semantico("Los operandos deben ser del mismo tipo");
      resultado = new RegistroExpr(Tipo_variable.DESCONOCIDO);
    }
    else if ((r1.tipo != Tipo_variable.DESCONOCIDO) && (r2.tipo != Tipo_variable.DESCONOCIDO) && 
    (r1.tipo == r2.tipo))
    {
      resultado = new RegistroExpr(r1, r2, operador);
    }
    return resultado;
  }
}

PARSER_END(MiniLenguaje)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "%" (~[ "\r", "\n" ])* ([ "\r", "\n" ]) >
  {
    if (MiniLenguaje.verbose) System.out.println("COMENTARIO");
  }
}

TOKEN : /* PALABRAS RESERVADAS */
{
  < tCLASE : "clase" >
  {
    if (MiniLenguaje.verbose) System.out.println("CLASE");
  }
| < tMETODO : "metodo" >
  {
    if (MiniLenguaje.verbose) System.out.println("METODO");
  }
| < tPROGRAMA : "programa" >
  {
    if (MiniLenguaje.verbose) System.out.println("PROGRAMA");
  }
| < tVAR : "var" >
  {
    if (MiniLenguaje.verbose) System.out.println("VAR");
  }
| < tAND : "and" >
  {
    if (MiniLenguaje.verbose) System.out.println("AND");
  }
| < tOR : "or" >
  {
    if (MiniLenguaje.verbose) System.out.println("OR");
  }
| < tNOT : "not" >
  {
    if (MiniLenguaje.verbose) System.out.println("NOT");
  }
| < tPRINCIPIO : "principio" >
  {
    if (MiniLenguaje.verbose) System.out.println("PRINCIPIO");
  }
| < tFIN : "fin" >
  {
    if (MiniLenguaje.verbose) System.out.println("FIN");
  }
| < tSI : "si" >
  {
    if (MiniLenguaje.verbose) System.out.println("SI");
  }
| < tENT : "ent" >
  {
    if (MiniLenguaje.verbose) System.out.println("ENT");
  }
| < tSI_NO : "si_no" >
  {
    if (MiniLenguaje.verbose) System.out.println("SI_NO");
  }
| < tFSI : "fsi" >
  {
    if (MiniLenguaje.verbose) System.out.println("FSI");
  }
| < tMQ : "mq" >
  {
    if (MiniLenguaje.verbose) System.out.println("MQ");
  }
| < tFMQ : "fmq" >
  {
    if (MiniLenguaje.verbose) System.out.println("FMQ");
  }
| < tESCRIBIR : "escribir" >
  {
    if (MiniLenguaje.verbose) System.out.println("ESCRIBIR");
  }
| < tLEER : "leer" >
  {
    if (MiniLenguaje.verbose) System.out.println("LEER");
  }
| < tMOD : "mod" >
  {
    if (MiniLenguaje.verbose) System.out.println("MOD");
  }
| < tTRUE : "true" >
  {
    if (MiniLenguaje.verbose) System.out.println("TRUE");
  }
| < tFALSE : "false" >
  {
    if (MiniLenguaje.verbose) System.out.println("FALSE");
  }
| < tENTACAR : "entacar" >
  {
    if (MiniLenguaje.verbose) System.out.println("ENTACAR");
  }
| < tCARAENT : "caraent" >
  {
    if (MiniLenguaje.verbose) System.out.println("CARAENT");
  }
| < tACCION : "accion" >
  {
    if (MiniLenguaje.verbose) System.out.println("ACCION");
  }
| < tVAL : "val" >
  {
    if (MiniLenguaje.verbose) System.out.println("VAL");
  }
| < tREF : "ref" >
  {
    if (MiniLenguaje.verbose) System.out.println("REF");
  }
}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
  {
    if (MiniLenguaje.verbose) System.out.println("ENTERO");
  }
| < tDECIMAL : "decimal" >
  {
    if (MiniLenguaje.verbose) System.out.println("DECIMAL");
  }
| < tBOOLEANO : "booleano" >
  {
    if (MiniLenguaje.verbose) System.out.println("BOOLEANO");
  }
| < tCARACTER : "caracter" >
  {
    if (MiniLenguaje.verbose) System.out.println("CARACTER");
  }
}

TOKEN : /* AGRUPACIONES */
{
  < tLLAVE_IZQ : "{" >
  {
    if (MiniLenguaje.verbose) System.out.println("LLAVE_IZQ");
  }
| < tLLAVE_DCHA : "}" >
  {
    if (MiniLenguaje.verbose) System.out.println("LLAVE_DCHA");
  }
| < tPARENTESIS_IZQ : "(" >
  {
    if (MiniLenguaje.verbose) System.out.println("PARENTESIS_IZQ");
  }
| < tPARENTESIS_DCHA : ")" >
  {
    if (MiniLenguaje.verbose) System.out.println("PARENTESIS_DCHA");
  }
| < tCORCHETE_IZQ : "[" >
  {
    if (MiniLenguaje.verbose) System.out.println("CORCHETE_IZQ");
  }
| < tCORCHETE_DCHA : "]" >
  {
    if (MiniLenguaje.verbose) System.out.println("CORCHETE_DCHA");
  }
}

TOKEN : /* OPERADORES */
{
  < tOPAS : ":=" >
  {
    if (MiniLenguaje.verbose) System.out.println("OPAS");
  }
| < tIGUAL : "=" >
  {
    if (MiniLenguaje.verbose) System.out.println("IGUAL");
  }
| < tFIN_SENTENCIA : ";" >
  {
    if (MiniLenguaje.verbose) System.out.println("FIN_SENTENCIA");
  }
| < tCOMA : "," >
  {
    if (MiniLenguaje.verbose) System.out.println("COMA");
  }
| < tMAS : "+" >
  {
    if (MiniLenguaje.verbose) System.out.println("MAS");
  }
| < tMENOS : "-" >
  {
    if (MiniLenguaje.verbose) System.out.println("MENOS");
  }
| < tPOR : "*" >
  {
    if (MiniLenguaje.verbose) System.out.println("POR");
  }
| < tDIV :
    "/"
  | "div" >
  {
    if (MiniLenguaje.verbose) System.out.println("DIV");
  }
| < tMAI : ">=" >
  {
    if (MiniLenguaje.verbose) System.out.println("MAYOR O IGUAL");
  }
| < tMEI : "<=" >
  {
    if (MiniLenguaje.verbose) System.out.println("MENOR O IGUAL");
  }
| < tNI : "<>" >
  {
    if (MiniLenguaje.verbose) System.out.println("NI");
  }
| < tMAYOR : ">" >
  {
    if (MiniLenguaje.verbose) System.out.println("MAYOR");
  }
| < tMENOR : "<" >
  {
    if (MiniLenguaje.verbose) System.out.println("MENOR");
  }
}

SKIP :
{
  "\"" : STRING
}

< STRING >
SKIP :
{
  < "\"" > 
  : DEFAULT
}

< STRING >
TOKEN :
{
  < tSTRING : (~[ "\"" ])+ >
  {
    if (MiniLenguaje.verbose) System.out.println("STRING (Valor: " + matchedToken + ")");
  }
}

TOKEN : /* VALORES */
{
  < tIDENTIFICADOR :
    ([ "a"-"z", "_" ]) ([ "a"-"z", "_", "0"-"9" ])* ([ "a"-"z", "0"-"9" ])
  | ([ "a"-"z", "_" ]) >
  {
    if (MiniLenguaje.verbose) System.out.println("IDENTIFICADOR (Valor: " + matchedToken + ")");
  }
| < tVALOR_ENTERO : ([ "0"-"9" ])+ >
  {
    if (MiniLenguaje.verbose) System.out.println("VALOR_ENTERO (Valor: " + matchedToken + ")");
  }
| < tVALOR_DECIMAL : ([ "0"-"9" ])+ "." ([ "0"-"9" ])+ >
  {
    if (MiniLenguaje.verbose) System.out.println("VALOR_DECIMAL (Valor: " + matchedToken + ")");
  }
}

/************************************
************* PROGRAMA **************
*************************************/

// <tPROGRAMA> <tIDENTIFICADOR> <tFIN_SENTENCIA> declaracion_variables() declaracion_acciones() bloque_sentencias()
void programa(boolean verbose) :
{}
{
  {
    tabla_simbolos = Tabla_simbolos.inicializar_tabla(31);
    nivel = 0;
  }
  < tPROGRAMA > < tIDENTIFICADOR >
  {
    tabla_simbolos.introducir_programa(token.image, TBD);
  }
  < tFIN_SENTENCIA > 
  declaracion_variables() 
  declaracion_acciones() 
  bloque_sentencias()
  {
    tabla_simbolos.eliminar_programa();
    System.out.println("Fin de programa");
  }
  < EOF >
}

// (declaracion()<tFIN_SENTENCIA>)*
void declaracion_variables() :
{}
{
  (
    try
    {
      declaracion() < tFIN_SENTENCIA >
    }
    catch (ParseException e)
    {
      error_sintactico(e);
      System.out.println("Entra aqui");
    }
  )*
}

// tipo_variables() identificadores()
void declaracion() :
{
  Tipo_variable tipo;
  ArrayList < String > identificadores;
}
{
  try
  {
    tipo = tipo_variables() 
    identificadores = identificadores()
    {
      for (String identificador : identificadores)
      {
        if (tabla_simbolos.introducir_variable(identificador, tipo, nivel, TBD) == null)
        {
          throw new ExcepcionTablaSimbolos(token,nivel, tabla_simbolos.buscar_simbolo(identificador));
        }
      }
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
  catch (ExcepcionTablaSimbolos e)
  {
    error_semantico(e);
  }
}

// <tENTERO> | <tCARACTER> | <tBOOLEANO> | <tDECIMAL>
Tipo_variable tipo_variables() :
{}
{
  < tENTERO >
  {
    return Tipo_variable.ENTERO;
  }
| < tCARACTER >
  {
    return Tipo_variable.CHAR;
  }
| < tBOOLEANO >
  {
    return Tipo_variable.BOOLEANO;
  }
| < tDECIMAL >
  {
    return Tipo_variable.DECIMAL;
  }
}

// <tIDENTIFICADOR>(<tCOMA><tIDENTIFICADOR>)*
ArrayList < String > identificadores() :
{
  ArrayList < String > identificadores = new ArrayList();
}
{
  try
  {
    < tIDENTIFICADOR >
    {
      identificadores.add(token.image);
    }
    (
    < tCOMA > < tIDENTIFICADOR >
    {
      identificadores.add(token.image);
    }
    ) *
    {
      return identificadores;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return identificadores;
  }
}

// (declaracion_accion())*
void declaracion_acciones() :
{}
{
  (
    try
    {
      declaracion_accion()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
  )*
}

// cabecera_accion() <tFIN_SENTENCIA> declaracion_variables() declaracion_acciones() bloque_sentencias()
void declaracion_accion() :
{}
{
  try
  {
    cabecera_accion() < tFIN_SENTENCIA > 
    declaracion_variables() 
    declaracion_acciones() bloque_sentencias()
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tACCION> <tIDENTIFICADOR> parametros_formales()
void cabecera_accion() :
{
  ArrayList < Simbolo > parametros;
  Simbolo accion;
}
{
  try
  {
    < tACCION > < tIDENTIFICADOR >
    {
      accion = tabla_simbolos.introducir_accion(token.image, nivel, TBD);
      if (accion == null)
      {
        error_semantico(new ExcepcionTablaSimbolos(token, nivel, tabla_simbolos.buscar_simbolo(token.image)));
      }
      nivel++;
      System.out.println("Aumenta nivel");
    }
    parametros = parametros_formales()
    {
      for (Simbolo parametro : parametros)
      {
        accion.introducir_parametro(parametro);
      }
    }
  }
  catch (ParseException e)
  {
    System.out.println("Excepcion sintactica");
    error_sintactico(e);
  }
  
}

// ((<tPARENTESIS_IZQ> parametros()) (<tFIN_SENTENCIA> parametros())* <tPARENTESIS_DCHA>)? 
ArrayList < Simbolo > parametros_formales() :
{
  if (MiniLenguaje.verbose) System.out.println("Parametros formales \n");
  ArrayList < Simbolo > parametros = new ArrayList < Simbolo > ();
  ArrayList < Simbolo > masParametros;
}
{
  try
  {
    (
    (
    < tPARENTESIS_IZQ > parametros = parametros()
    ) 
    (
    < tFIN_SENTENCIA > masParametros = parametros()
    {
      parametros.addAll(masParametros);
    }
    ) * 
    < tPARENTESIS_DCHA >
    ) ?
    {
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// expresion() (<tCOMA> expresion())*
ArrayList < Simbolo > lista_parametros(Clase_parametro clase, Tipo_variable tipo) :
{
  ArrayList < String > identificadores;
  ArrayList < Simbolo > parametros = new ArrayList();
  Simbolo parametro;
}
{
  try
  {
    identificadores = identificadores()
    {
      for (String identificador : identificadores)
      {
        parametro = tabla_simbolos.introducir_parametro(identificador, tipo, clase, nivel, TBD);
        if (parametro == null)
        {
          throw new ExcepcionTablaSimbolos(token, nivel, tabla_simbolos.buscar_simbolo(identificador));
        }
        else
        {
          parametros.add(parametro);
        }
      }
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
  catch (ExcepcionTablaSimbolos e)
  {
    error_semantico(e);
  }
}

// clase_parametros() tipo_variables() lista_parametros()
ArrayList < Simbolo > parametros() :
{
  Clase_parametro clase;
  Tipo_variable tipo;
  ArrayList < Simbolo > parametros = new ArrayList();
}
{
  try
  {
    clase = clase_parametros() 
    tipo = tipo_variables() 
    parametros = lista_parametros(clase, tipo)
    {
      return parametros;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return parametros;
  }
}

// <tVAL> | <tREF>
Clase_parametro clase_parametros() :
{}
{
  < tVAL >
  {
    return Clase_parametro.VAL;
  }
| < tREF >
  {
    return Clase_parametro.REF;
  }
}

// <tPRINCIPIO> lista_sentencias() <tFIN>
void bloque_sentencias() :
{}
{
  try
  {
    < tPRINCIPIO > lista_sentencias() < tFIN >
    {
      //System.out.println("######################################################################################");    
      //System.out.println("Tabla antes de borrar nivel " + nivel);
      //System.out.println(tabla_simbolos);
      tabla_simbolos.ocultar_parametros(nivel);
      tabla_simbolos.eliminar_variables(nivel);
      // Elimino los parámetros ocultos al eliminar las acciones
      tabla_simbolos.eliminar_acciones(nivel);
      nivel--;
      //System.out.println("\nTabla despues de borrar nivel " + (nivel + 1));
      //System.out.println(tabla_simbolos);
      //System.out.println("######################################################################################");
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// (sentencia())* 
void lista_sentencias() :
{}
{
  (
    try
    {
      sentencia()
    }
    catch (ParseException e)
    {
      error_sintactico(e);
    }
  )+
}

/*
leer()  < tFIN_SENTENCIA >|
  escribir() < tFIN_SENTENCIA >|
  < tIDENTIFICADOR > [asignacion() |  invocacion_accion() ] < tFIN_SENTENCIA > |
  seleccion()  |
  mientras_que()
  */
void sentencia() :
{}
{
  try
  {
    leer() < tFIN_SENTENCIA >
  | 
    escribir() < tFIN_SENTENCIA >
  | 
    < tIDENTIFICADOR >
    [
      asignacion()
    | invocacion_accion()
    ]
    < tFIN_SENTENCIA >
  | 
    seleccion()
  | 
    mientras_que()
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tLEER> <tPARENTESIS_IZQ> lista_asignables() <tPARENTESIS_DCHA>
void leer() :
{}
{
  try
  {
    < tLEER > < tPARENTESIS_IZQ > lista_asignables() < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tIDENTIFICADOR> (<tCOMA> <tIDENTIFICADOR>)*
void lista_asignables() :
{}
{
  try
  {
    < tIDENTIFICADOR > (< tCOMA > < tIDENTIFICADOR >) *
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tESCRIBIR> <tPARENTESIS_IZQ> lista_escribibles() <tPARENTESIS_DCHA>
void escribir() :
{}
{
  try
  {
    < tESCRIBIR > < tPARENTESIS_IZQ > lista_escribibles() < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// expresion() (<tCOMA> expresion())*
void lista_escribibles() :
{}
{
  try
  {
    expresion() 
    (
    < tCOMA > expresion()
    ) *
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tOPAS> expresion() 
void asignacion() :
{}
{
  try
  {
    < tOPAS > expresion()
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// argumentos() 
void invocacion_accion() :
{}
{
  try
  {
    argumentos()
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tMQ> expresion() lista_sentencias() <tFMQ>
void mientras_que() :
{}
{
  try
  {
    < tMQ > expresion() lista_sentencias() < tFMQ >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tSI> expresion() <tENT> lista_sentencias() (<tSI_NO> lista_sentencias())?  <tFSI>
void seleccion() :
{}
{
  try
  {
    < tSI > expresion() < tENT > lista_sentencias() 
    (
    < tSI_NO > lista_sentencias()
    ) ? 
    < tFSI >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tPARENTESIS_IZQ> (lista_expresiones())? <tPARENTESIS_DCHA>
void argumentos() :
{}
{
  try
  {
    < tPARENTESIS_IZQ > 
    (
    lista_expresiones()
    ) ? 
    < tPARENTESIS_DCHA >
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// expresion() (<tCOMA> expresion())*
void lista_expresiones() :
{}
{
  try
  {
    expresion() 
    (
    < tCOMA > expresion()
    ) *
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// expresion_simple() (operador_relacional() expresion_simple())*
RegistroExpr expresion() :
{
  RegistroExpr r1, r2, resultado = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = expresion_simple() 
    (
    token_operador = operador_relacional() 
    r2 = expresion_simple()
    {
      operador = token_operador.image;
      resultado = comprobacionExpresion(r1, r2, operador);
      /*switch (operador)
      {
        case "=" :         
        break;
        case "<>" :        
        break;
        case "<" : 
        break;
        case "<=" : 
        break;
        case ">" : 
        break;
        case ">=" : 
        break;
      }*/

    }
    ) ?
    {
      return resultado;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
  }
}

// <tMAYOR> | <tMENOR> | <tMAI> | <tMEI> | <tNI> | <tIGUAL>
Token operador_relacional() :
{
  Token t;
}
{
  t = < tMAYOR >
  {
    return t;
  }
| t = < tMENOR >
  {
    return t;
  }
| t = < tMAI >
  {
    return t;
  }
| t = < tMEI >
  {
    return t;
  }
| t = < tNI >
  {
    return t;
  }
| t = < tIGUAL >
  {
    return t;
  }
}

// termino() (operador_aditivo() termino())*
RegistroExpr expresion_simple() :
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = termino() 
    (
    token_operador = operador_aditivo() 
    r2 = termino()
    {
      operador = token_operador.image;
      switch (operador)
      {
        case "+" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= (2^ 16) || r1.valorEnt < (- (2^ 16))))
          {
            error_semantico("Error de overflow/underflow al realizar la suma.");
            r1.valorEnt = null;
          }
        }
        break;
        case "-" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= (2^ 16) || r1.valorEnt < (- (2^ 16))))
          {
            error_semantico("Error de overflow/underflow al realizar la resta.");
            r1.valorEnt = null;
          }
        }
        break;
        case "or" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba booleano.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);				
        }			
        break;
      }
    }
    ) *
    {
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return r1;
  }
}

// <tMAS> | <tMENOS> | <tOR>
Token operador_aditivo() :
{
  Token t;
}
{
  t = < tMAS >
  {
    return t;
  }
| t = < tMENOS >
  {
    return t;
  }
| t = < tOR >
  {
    return t;
  }
}

// factor() (operador_multiplicativo() factor())* 
RegistroExpr termino() :
{
  RegistroExpr r1 = new RegistroExpr(), r2 = new RegistroExpr();
  Token token_operador;
  String operador;
}
{
  try
  {
    r1 = factor() 
    (
    token_operador = operador_multiplicativo() 
    r2 = factor()
    {
      operador = token_operador.image;
      switch (operador)
      {
        case "*" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          r1 = new RegistroExpr(r1, r2, operador);
          if (r1.valorEnt != null && (r1.valorEnt >= (2^ 16) || r1.valorEnt < (- (2^ 16))))
          {
            error_semantico("Error de overflow/underflow al realizar la multiplicacion.");
            r1.valorEnt = null;
          }
        }
        break;
        case "div" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Division por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        break;
        case "/" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Division por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        break;
        case "mod" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba entero.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {
          if (r2.valorEnt != null && r2.valorEnt == 0)
          {
            error_semantico("Modulo por 0");
            r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
          }
          else
          {
            r1 = new RegistroExpr(r1, r2, operador);
          }				
        }
        break;
        case "and" : 
        if ((r1.tipo != Tipo_variable.ENTERO) && (r1.tipo != Tipo_variable.DESCONOCIDO) 
        || (r2.tipo != Tipo_variable.ENTERO) && (r2.tipo != Tipo_variable.DESCONOCIDO))
        {
          error_semantico("Tipo incompatible. Se esperaba booleano.");
          r1 = new RegistroExpr(Tipo_variable.DESCONOCIDO);
        }
        else
        {				
          r1 = new RegistroExpr(r1, r2, operador);						
        }
        break;			
      }
    }
    ) *
    {
      return r1;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return r1;
  }
}

// <tPOR> | <tDIV> | <tMOD> | <tAND>
Token operador_multiplicativo() :
{
  Token t;
}
{
  t = < tPOR >
  {
    return t;
  }
| t = < tDIV >
  {
    return t;
  }
| t = < tMOD >
  {
    return t;
  }
| t = < tAND >
  {
    return t;
  }
}

/*
	< tMENOS > factor()
| < tNOT > factor()
| < tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tENTACAR > <tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tCARAENT > <tPARENTESIS_IZQ > expresion() < tPARENTESIS_DCHA >
| < tIDENTIFICADOR >
| < tVALOR_ENTERO >
| < tVALOR_DECIMAL >
| < tSTRING >
| < tTRUE >
| < tFALSE >
*/
RegistroExpr factor() :
{
  RegistroExpr rExpr = new RegistroExpr();
  Token t;
  Simbolo s;
}
{
  try
  {
    < tMENOS > rExpr = factor()
    {
      if ((rExpr.tipo != Tipo_variable.ENTERO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.ENTERO));
        rExpr.tipo = Tipo_variable.ENTERO;
      }
      if (rExpr.valorEnt != null)
      {
        rExpr.valorEnt = - rExpr.valorEnt;
      }
      return rExpr;
    }
  | < tNOT > rExpr = factor()
    {
      if ((rExpr.tipo != Tipo_variable.BOOLEANO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.BOOLEANO));
        rExpr.tipo = Tipo_variable.BOOLEANO;
      }
      if (rExpr.valorBool != null)
      {
        rExpr.valorBool = !rExpr.valorBool;
      }
      return rExpr;
    }
  | < tPARENTESIS_IZQ > rExpr = expresion() < tPARENTESIS_DCHA >
    {
      return rExpr;
    }
  | < tENTACAR > < tPARENTESIS_IZQ > rExpr = expresion() < tPARENTESIS_DCHA >
    {
      if ((rExpr.tipo != Tipo_variable.ENTERO) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.ENTERO));
        System.out.println(rExpr);
      }
      if ((rExpr.valorEnt != null) && (rExpr.valorEnt > 255))
      {
        error_semantico("La expresion no se puede convertir en un caracter valido");
      }
      rExpr.tipo = Tipo_variable.CHAR;
      return rExpr;
    }
  | < tCARAENT > < tPARENTESIS_IZQ > rExpr = expresion() < tPARENTESIS_DCHA >
    {
      if ((rExpr.tipo != Tipo_variable.CHAR) && (rExpr.tipo != Tipo_variable.DESCONOCIDO))
      {
        error_semantico(new ExcepcionTipo(token, rExpr.tipo, Tipo_variable.CHAR));
      }
      rExpr.tipo = Tipo_variable.ENTERO;
      return rExpr;
    }
  | t = < tIDENTIFICADOR >
    {
      s = tabla_simbolos.buscar_simbolo(t.image);
      rExpr = new RegistroExpr();
      if (s == null)
      {
        error_semantico("Identificador desconocido");
        tabla_simbolos.introducir_variable(token.image, Tipo_variable.DESCONOCIDO, nivel, TBD);	
        rExpr.tipo = Tipo_variable.DESCONOCIDO;
      }
      else
      {
        rExpr.tipo = s.getVariable();
      }
      return rExpr;	
    }
  | t = < tVALOR_ENTERO >
    {
      rExpr = new RegistroExpr();
      rExpr.valorEnt = Integer.parseInt(t.image);
      rExpr.tipo = Tipo_variable.ENTERO;
      return rExpr;
    }
  | t = < tVALOR_DECIMAL >
    {
      rExpr = new RegistroExpr();
      rExpr.valorDecimal = Float.parseFloat(t.image);
      rExpr.tipo = Tipo_variable.DECIMAL;
      return rExpr;
    }
  | t = < tSTRING >
    {
      rExpr = new RegistroExpr();
      rExpr.valorChar = t.image;
      rExpr.tipo = Tipo_variable.CHAR;
      return rExpr;
    }
  | t = < tTRUE >
    {
      rExpr = new RegistroExpr();
      rExpr.valorBool = true;
      rExpr.tipo = Tipo_variable.BOOLEANO;
      return rExpr;
    }
  | t = < tFALSE >
    {
      rExpr = new RegistroExpr();
      rExpr.valorBool = false;
      rExpr.tipo = Tipo_variable.BOOLEANO;
      return rExpr;
    }
  }
  catch (ParseException e)
  {
    error_sintactico(e);
    return rExpr;
  }
}
